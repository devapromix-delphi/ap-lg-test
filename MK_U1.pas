unit MK_U1;

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, JPEG, ExtCtrls, Grids, DBGrids, Db, DBTables, DBCtrls, Buttons;

{TODO: Добавить возможность редактировать кол-во веток просто выбрав строку и изменив число веток (автоматом тогда нужно или добавить в бд записи или удалить лишние)}
{TODO: Если ввести в поле команду, она должна зап. в базу и поля редакт.}
{TODO: Реализовать несколько перегружаемых процедур Dialog()}
{TODO: Реализовать команду ВЫПОЛНИТЬ (например, ВЫПОЛНИТЬ 5 - где 5 это строка с целым алгоритмом}
{TODO: Команда ВЕТКА (например, ВЕТКА 200 - где 200 это номер блока CASE}
{TODO: Реализовать ввод (?) и вывод (!) значений переменных}

type
  //
  TTable = class(DBTables.TTable)
    {TODO: Реализовать метод SaveToField}
    procedure SaveToField(const FieldID, Value: string); overload;
  end;

type
  // Тип - динамический список строк
  TExplodeResult  = array of string;
  {TODO: Реализовать функцию разбивки строк для парсера}

//===================================================
type
  // Команды, которые может вводить человек в диалоговое окно
  TCmdEnum = (cmdNihil, cmdSozdat, cmdNazvat, cmdBlok, cmdUslovie, cmdVetok, cmdVetka, cmdVypolnit, cmdNajti, cmdUdalit);

const
  // Все команды
  cCmdName: array [TCmdEnum] of string =
    ('ПУСТО', 'СОЗДАТЬ', 'НАЗВАТЬ', 'БЛОК', 'УСЛОВИЕ', 'ВЕТОК', 'ВЕТКА', 'ВЫПОЛНИТЬ', 'НАЙТИ', 'УДАЛИТЬ');

//type
   //варианты команд, которые может вводить человек в диалоговое окно
   //"пусто", СОЗДАТЬ, НАЗВАТЬ, БЛОК, УСЛОВИЕ, ВЕТОК, "создать переменную и присвоить ей значение", ВЫПОЛНИТЬ
   //TComand = (Nihil, Sozdat, Nazvat, Blok, Uslovie, Vetok, Vetka, Ravno, Vypolnit);

type
   //обозначения для типов переменных
  TTip = (O, I, R, S, L); //типы переменных в порядке объявления: нет, целое, вещественное, строковое, логическое

//--------------------------------------------------------

type
   //новый тип - указатель на объект типа Стандартная Универасльная Процедура в блоке CASE
  TPCASEPrcdr   = ^TCASEPrcdr;

  //объект - одно значение (ветка) в блоке CASE (объект для создания и описания алгоритмов)
  TCASEPrcdr = record
    //основные данные (см. схему Стандартоной Универсальной Процедуры для блока CASE)
   ID           : Integer;   //порядковый номер записи в БД CASEBD (её ID)
   N            : Integer;   //номер этой ветки в блоке CASE
   P            : String;    //выражение, либо имя вызываемой процедуры
   P_ID         : Integer;   //ID записи в БД Алгоритмов, на которую ссылается данная процедура
   P_N_Alg      : Integer;   //Номер в массиве Алгоритмов, на который ссылается данная процедура
   ID_Rod       : Integer;   //ID родительской записи в БД Алгоритмов (в которой описаны эти ветки CASE)
   Alg_Rod      : Integer;   //номер ячейки с родительским Алгоритмом
   Flg_Zanat    : Boolean;   //флаг занятости/свободы этой ячейки
    //цепочка следования "полных" ячеек (добавлется всегда в начало, но удаляться может из любого места)
   Next_P       : Integer;   //указатель на следующую "занятую"/"пустую" ячейку для их обхода при проверке
   Pred_P       : Integer;   //указатель на предыдущую "занятую"/"пустую" ячейку (для корректного удаления)
    //цепочка следования веток внутри одного блока CASE в текущем алгоритме (по порядку номеров внутри своего блока)
   Next_N       : Integer;   //указатель на следующую ячейку - ветку в этом же блоке CASE - для их обхода при проверке
   Pred_N       : Integer;   //указатель на предыдущую ячейку - ветку в этом же блоке CASE - (для корректного удаления)
    //цепочка следования "пустых" ячеек (добавляется всегда в начало, удаляется/забирается тоже только с начала), на начало указывает переменная
   Next_Z       : Integer;   //указатель на следующую "связанную" "пустую" ячейку в цепочке
  end; //конец описания записи одного значения (ветки) в блоке CASE

//--------------------------------------------------------

   //новый тип - указатель на объект типа Алгоритм - Стандартная Универасльная Процедура
  TPAlg   = ^TAlg;

    //объект - Алгоритм - Стандартная Универасльная Процедура (объект для создания и описания алгоритмов)
  TAlg = record
    //основные данные (см. схему Стандартоной Универсальной Процедуры)
   ID           : Integer;     //порядковый номер записи в БД (её ID)
   IM           : String[15];  //имя этой процедуры (в БД строка 15 символов) - генерирует программа
   DLN_IM       : String[50];  //длинное имя процедуры, если его даст человек
   P1           : String[20];  //Процедура 1 (см. схему), выражение, либо вызов другой процедуры (вызов - просто номер записи в массиве Алгоритмов)
   P1_N         : Integer;     //Номер в массиве Алгоритмов, на который ссылается данная процедура
   P1_ID        : Integer;     //ID записи в БД Алгоритмов, на которую ссылается данная процедура
   P2           : String[20];  //Процедура 2 (см. схему), либо выражение
   P2_N         : Integer;     //Номер в массиве Алгоритмов, на который ссылается данная процедура
   P2_ID        : Integer;     //ID записи в БД Алгоритмов, на которую ссылается данная процедура
   U1           : String[30];  //Условие 1 (см. схему), логическое выражение
   P3           : String[20];  //Процедура 3 (см. схему), либо выражение
   P3_N         : Integer;     //Номер в массиве Алгоритмов, на который ссылается данная процедура
   P3_ID        : Integer;     //ID записи в БД Алгоритмов, на которую ссылается данная процедура
   NC           : Integer;     //количество ветвей в выборе CASE (сами ветки в другой БД)
   NAME         : String[15];  //имя пользовательской переменной для блока CASE
   TIP          : Integer;     //тип пользовательской переменной для блока CASE (перечисляемого типа) - заменил на целый тип
   SPISOK       : String[255]; //список значений пользовательской переменной для блока CASE (через точку с запятой)
   P4           : String[20];  //Процедура 4 (см. схему), либо выражение
   P4_N         : Integer;     //Номер в массиве Алгоритмов, на который ссылается данная процедура
   P4_ID        : Integer;     //ID записи в БД Алгоритмов, на которую ссылается данная процедура
   U2           : String[30];  //Условие 2 (см. схему), логическое выражение
   P5           : String[20];  //Процедура 5 (см. схему), либо выражение
   P5_N         : Integer;     //Номер в массиве Алгоритмов, на который ссылается данная процедура
   P5_ID        : Integer;     //ID записи в БД Алгоритмов, на которую ссылается данная процедура
   P6           : String[20];  //Процедура 6 (см. схему), либо выражение
   P6_N         : Integer;     //Номер в массиве Алгоритмов, на который ссылается данная процедура
   P6_ID        : Integer;     //ID записи в БД Алгоритмов, на которую ссылается данная процедура
   P7           : String[20];  //Процедура 7 (см. схему), либо выражение
   P7_N         : Integer;     //Номер в массиве Алгоритмов, на который ссылается данная процедура
   P7_ID        : Integer;     //ID записи в БД Алгоритмов, на которую ссылается данная процедура
   P8           : String[20];  //Процедура 8 (см. схему), либо выражение
   P8_N         : Integer;     //Номер в массиве Алгоритмов, на который ссылается данная процедура
   P8_ID        : Integer;     //ID записи в БД Алгоритмов, на которую ссылается данная процедура
   I            : Integer;     //текущее значение выполняемого цикла (для подсчета и организации цикла типа For)
   U_1_CASE     : Integer;     //ссылка на самую первую запись в блоке (массиве) ветвей CASE
   Flg_Zanat    : Boolean;     //флаг занятости/свободы этой ячейки
    //цепочки следования "полных" ячеек (добавляется вегда в начало, но удаляться может из любого места), на начало указывает переменная
   Next_P       : Integer;     //указатель на следующую "занятую"/"пустую" ячейку для их корректного удаления
   Pred_P       : Integer;     //указатель на предыдущую "занятую"/"пустую" ячейку для их корректного удаления
    //цепочка следования "пустых" ячеек (добавлется всегда в начало, удаляется/забирается тоже всегда с начала), на начало указывает переменная
   Next_Z       : Integer;     //указатель на следующую "связанную" "пустую" ячейку в цепочке (для удобного заполнения)
  end; //конец описания записи Алгоритм - Стандартная Универасльная Процедура

//--------------------------------------------------------
   //новый тип - указатель на объект типа Процедура
  TPPrcdr   = ^TPrcdr;

    //объект - Процедура
  TPrcdr = record
    //основные данные (см. схему Стандартоной Универсальной Процедуры с именем)
   ID           : Integer;   //порядковый номер записи в БД (её ID)
   Alg          : TAlg;      //Стандартный Универсальный Алгоритм
   IM           : String;    //имя этой процедуры (в БД строка 15 символов) - генерирует программа
   DLN_IM       : String;    //длинное имя процедуры, если его даст человек
  end; //конец описания записи Процедуры (с именем)

//--------------------------------------------------------
   //новый тип - указатель на объект типа ПРОЦЕСС
  TPPrcss   = ^TPrcss;

    //объект - ПРОЦЕСС (может быть запущено сразу несколько процессов, и все их нужно отслеживать)
  TPrcss = record
    //основные данные
   ID           : Integer;   //порядковый номер записи в БД (её ID)
   Celi         : Integer;   //ID ЦЕЛИ, которую преследует данный процесс
   Prav         : Integer;   //ID ПРАВИЛА, который запустил этот процесс
   Model        : Integer;   //ID Модели, которую обсчитывает этот процесс
   Chel         : Integer;   //ID Человека (м.б. и сама программа), которого обсчитывает этот процесс
   Zanyat       : Boolean;   //флаг, что эта запись в базе данных задействована
   Spit         : Boolean;   //флаг, что этот процесс находится в спящем состоянии
   Rang         : Integer;   //ранг (степень важности) процесса - для подсчета пропусков до повтора
   Num_Prpsk    : Integer;   //счетчик числа пропусков (до повтора очередного шага процесса)
   Alg          : Integer;   //ID Процедуры, которую запустил ПЕРВОЙ этот процесс
   N_Prcdr      : Integer;   //порядковый номер запускаемой процедуры, в рамках этого процесса
   Cikl         : Boolean;   //флаг, что текущая процедура этого процесса выполняется в цикле (не полностью)
  end; //конец описания записи ПРОЦЕСС

//--------------------------------------------------------
   //новый тип - указатель на объект типа СТЕК ПРОЦЕДУР
  TPStekPrcdr   = ^TStekPrcdr;

    //объект - СТЕК ПРОЦЕДУР (для отслеживания порядка запускаемых процедур и их правильного закрытия)
  TStekPrcdr = record
    //основные данные
   ID           : Integer;   //порядковый номер записи в БД (её ID)
   Prcss        : Integer;   //ID ПРОЦЕССА, к которому относится данная запущенная процедура
   Prcdr        : Integer;   //ID ПРОЦЕДУРЫ, которую запустил этот процесс
   N_Prcdr      : Integer;   //порядковый номер этой запускаемой процедуры, в рамках этого процесса
   N            : Integer;   //текущее значение CASE в блоке выбора этой процедуры
   I            : Integer;   //текущее значение выполняемого цикла (для подсчета и организации цикла типа For)
  end; //конец описания записи СТЕК ПРОЦЕДУР



//--------------------------------------------------------

type
   //основная форма
  TForm1 = class(TForm)
    Tb_Alg: TTable;
    DS_Alg: TDataSource;
    Tb_Im: TTable;
    DS_Im: TDataSource;
    Tb_CASE: TTable;
    DS_CASE: TDataSource;
    Tb_Int: TTable;
    DS_Int: TDataSource;
    Tb_Num: TTable;
    DS_Num: TDataSource;
    Tb_Str: TTable;
    DS_Str: TDataSource;
    Tb_Log: TTable;
    DS_Log: TDataSource;
    Tb_Prm_Int: TTable;
    DS_Prm_Int: TDataSource;
    Img_Panel: TPanel;
    Img262x473: TImage;
    Help_Panel: TPanel;
    M2: TMemo;
    Text_Panel: TPanel;
    M3: TMemo;
    SpeedButton1: TSpeedButton;
    Pnl_BD: TPanel;
    Pnl_PU: TPanel;
    Label11: TLabel;
    Label2: TLabel;
    Label4: TLabel;
    Label5: TLabel;
    Label7: TLabel;
    Label3: TLabel;
    Label6: TLabel;
    Label8: TLabel;
    Label9: TLabel;
    Label10: TLabel;
    E_Dln_Str_P1: TEdit;
    E_Dln_Str_P2: TEdit;
    E_Dln_Str_U1: TEdit;
    E_Dln_Str_P3: TEdit;
    E_Dln_Str_P4: TEdit;
    E_Dln_Str_U2: TEdit;
    E_Dln_Str_P5: TEdit;
    E_Dln_Str_P6: TEdit;
    E_Dln_Str_P7: TEdit;
    E_Dln_Str_P8: TEdit;
    DBG_Alg: TDBGrid;
    L_Im: TLabel;
    Edit1: TEdit;
    DBNav1: TDBNavigator;
    Pnl_CASE: TPanel;
    Label1: TLabel;
    DBG_CASE: TDBGrid;
    Pnl_Dlg: TPanel;
    M1: TMemo;
    E1: TEdit;
    Bt1: TButton;
    Label12: TLabel;
    E_Dln_Str_SPISOK: TEdit;
    Label13: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure Bt1Click(Sender: TObject);
    procedure Tb_CASEFilterRecord(DataSet: TDataSet; var Accept: Boolean);
    procedure DBNav1Click(Sender: TObject; Button: TNavigateBtn);
    procedure Tb_ImFilterRecord(DataSet: TDataSet; var Accept: Boolean);
    procedure E_Dln_Str_P1Change(Sender: TObject);
    procedure E_Dln_Str_P2Change(Sender: TObject);
    procedure E_Dln_Str_P3Change(Sender: TObject);
    procedure E_Dln_Str_P4Change(Sender: TObject);
    procedure E_Dln_Str_P5Change(Sender: TObject);
    procedure E_Dln_Str_P6Change(Sender: TObject);
    procedure E_Dln_Str_P7Change(Sender: TObject);
    procedure E_Dln_Str_P8Change(Sender: TObject);
    procedure E_Dln_Str_U1Change(Sender: TObject);
    procedure E_Dln_Str_U2Change(Sender: TObject);
  private
    { Private declarations }
    procedure Tb_Alg_Edit;
  public
    { Public declarations }
    procedure DoCmdRun(const AlgName: string); // Выполнить алгоритм
  end;

//===================================================
//Глобальные процедуры
 procedure cmd_Sozdat(S : String);  //если была введена команда СОЗДАТЬ (процедуру), и возможно было введено новое имя для нее
 procedure cmd_Nazvat(S : String);  //если была введена команда НАЗВАТЬ (процедуру) - введено новое имя для нее
 procedure input_NCASE(S : String); //если была введена команда NCASE (ввод строковой части команды)
 procedure cmd_Vetok(S : String);   //если была введена команда ВЕТОК (задать количество ветвей в блоке CASE)
 procedure Zap_Tek_Alg();           //процедура заполнения ячеек массивов по текущей записи БД
 procedure Pozicia();               //процедура поиска и выставления активной ячейки по текущей записи в БД Алгоритмов



procedure cmd_Blok(S: String);
procedure cmd_Vypolnit(S: String);
procedure cmd_Uslovie(S: String);




//===================================================
var
  Form1: TForm1;
//===================================================
   //глобальные переменные
  ID_Rod  : Integer; //для получения ID родителя в БД Алгоритмов
  ID_CASE : Integer; //для получения ID в БД CASE
  s_ID    : string;  //для преобразования ID в строку (для осуществления поиска)
  s_Im    : string;  //для отображения имени процедуры

   //основные переменные для работы
  Kol_Proc  : Integer; //для подсчета созданных процедур-алгоритмов
  Im_Proc   : String;  //(внутреннее) имя создаваемой процедуры

  log_Flag  : Boolean; //флаг для разных случаев
  int_N     : Integer; //количество ветвей в блоке CASE в текущем Алгоритме

  Alg       : TAlg;    //объект Алгоритм (для обработки текущего Алгоритма)

   //"нулевые" ячейки в массивах нужны для правильности обработки
   //массив "связанных" ячеек для хранения Алгоритмов ("связанные" они потому, что указывают на следующую "пустую")
  Blok_Alg  : array[0..5000] of TAlg;  //5000 ячеек для "связанных" записей Универсальных Алгоритмов
  U_Z_Alg   : Integer;   //указатель на первую "свободную" ячейку в таблице "связанных" ячеек для записи Алгоритмов
  U_P_Alg   : Integer;   //указатель на первую "занятую" ячейку в массиве Алгоритмов
  U_Alg     : Integer;   //указатель на текущую ячйку в массиве алгоритмов
  Kol_Alg   : Integer;   //количество заполненных ячеек в массиве Алгоритмов

  Kol_Jach_Alg : Integer; //кличество ячеек для хранения Алгоритмов

   //для организации хранения записей значений ветвей в блоках CASE
  Blok_CASE : array[0..20000] of TCASEPrcdr; //20000 ячеек для "связанных" записей отдельных ветвей в блоках CASE
  U_Z_CASE  : Integer;   //указатель на первую "свободную" ячейку в таблице "связанных" записей ветвей блоков CASE
  U_P_CASE  : Integer;   //указатель на первую "занятую" ячейку в массиве веток CASE
  U_CASE    : Integer;   //указатель на текущую ячейку в таблице записей ветвей блоков CASE
  Kol_CASE  : Integer;   //количество заполненных ячеек в массиве веток CASE

  Kol_Jach_CASE : Integer; //количество ячеек для хранения веток CASE

//===================================================
implementation

{$R *.DFM}

{ TTable }

// Запись строки в таблицу
procedure TTable.SaveToField(const FieldID, Value: string);
begin
  Self.Edit;
  Self.FieldByName(FieldID).AsString   := Trim(Value);
  Self.Post;
end;

// Сравнение введенной строки Str на содержание команды Cmd
function HasCmd(Str, Cmd: string): Boolean;
begin
  Result := Copy(Str,1,Length(Cmd)) = Cmd;
end;

// Получаем команду
function GetCmd(Str: string): TCmdEnum;
begin
  Str := Trim(Str);
  for Result := Low(TCmdEnum) to High(TCmdEnum) do
    if HasCmd(Str, cCmdName[Result]) then
    begin
      Form1.M1.Lines.Add('Введена команада: ' + Str);  //переносим то, что получилось, в диалоговое окно
      Form1.E1.SetFocus;
      Exit;
    end;
  Result := cmdNihil;
end;

// Разбиваем строку по пробелам и сохраняем в массиве
function Explode(Str: string): TExplodeResult;
var
  I: Integer;
  S: string;
begin
  S := Str;
  SetLength(Result, 0);
  I := 0;
  while Pos(#32, S) > 0 do
  begin
    S := Trim(S);
    SetLength(Result, Length(Result) + 1);
    Result[I] := Copy(S, 1, Pos(#32, S) - 1);
    Inc(I);
    S := Copy(S, Pos(#32, S) + 1, Length(S));
  end;
  SetLength(Result, Length(Result) + 1);
  Result[I] := Copy(S, 1, Length(S));
end;

// Функция собирает строку из массива (можно указать, с какой позиции N начать)
function Implode(A: TExplodeResult; N: Integer = 0): string;
var
  I: Integer;
begin
  Result := '';
  if N <= Length(A) then
    for I := N to Length(A) do
      if I <> Length(A) then
        Result := Result + Trim(A[I]) + #32
      else
        Result := Result + Trim(A[I]);
end;

// Пишем в диалоговое окно
procedure Dialog(Str: string); overload;
begin
  Form1.M1.Lines.Add(Str); //записываем значение Str в диалоговое окно
  Form1.E1.SetFocus; //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
end;

procedure Dialog(Str, Value: string); overload;
begin
  Dialog(Str + #32 + Value);
end;

//==================================================
//при создании формы
procedure TForm1.FormCreate(Sender: TObject);
 var
  int_i : Integer; //временная переменная для циклов

 begin
    //активируем подключенные Базы Данных
  Tb_Alg.Active      := True;  //подключаем основную базу - Универсальный Алгоритм
  Tb_Im.Active       := True;  //подключаем вспомогательную базу - Имя процедуры
  Tb_CASE.Active     := True;  //подключаем вспомогательную базу - блок CASE
  Tb_Int.Active      := True;  //подключаем базу переменных - Целое
  Tb_Num.Active      := True;  //подключаем базу переменных - Вещественное
  Tb_Str.Active      := True;  //подключаем базу переменных - Строковое
  Tb_Log.Active      := True;  //подключаем базу переменных - Логическое
  Tb_Prm_Int.Active  := True;  //подключаем базу - Параметры программы (целочисленные)

    //попытка установить указатель на текущую запись в БД имен процедур

   //указатель стоит на текущей записи в БД Алгоритмов
  ID_Rod := Tb_Alg.FieldByName('ID').AsInteger; //берем ID родителя (текущая запись)
   //фильтруем записи в БД CASE в заисимости от ID родительской БД Алгоритмов
  Tb_CASE.Filtered := False; //выключаем (на время) фильтрацию
  Tb_CASE.Filtered := True;  //включаем фильтрацию
   //фильтруем записи в БД имен процедур в заисимости от ID родительской БД Алгоритмов
  Tb_Im.Filtered := False; //выключаем (на время) фильтрацию
  Tb_Im.Filtered := True;  //включаем фильтрацию

   //переносим название (имя процедуры, если есть) в текстовую строку (заголовок)
  s_Im := Tb_Im.FieldByName('DLN_IM').AsString; //берем имя процедуры (если оно там есть)
   //проверяем, что получилось
  if s_Im = '' then //если там ничего не было
   begin //очищаем строку вывода имени процедуры
    L_Im.Caption := ''; //пусто
   end
  else  //имя у процедуры есть
   begin
    L_Im.Caption := s_Im; //переносим полученное имя процедуры в окно строки
   end;

   //берем значения важных для нас параметров из БД параметров (изначально в БД должно быть введено значение 0)
  Kol_Proc := Tb_Prm_Int.FieldByName('KOL_PRC').AsInteger; //берем количество уже созданных процедур

//   //массив "связанных" ячеек для хранения Алгоритмов ("связанные" они потому, что указывают на следующую "пустую")
//  Blok_Alg  : array[1..5000] of TAlg;  //5000 ячеек для "связанных" записей Универсальных Алгоритмов
//  U_Z_Alg   : Integer;   //указатель на первую "свободную" ячейку в таблице "связанных" ячеек для записи Алгоритмов
//  U_P_Alg   : Integer;   //указатель на первую "занятую" ячейку в массиве Алгоритмов
//  U_Alg     : Integer;   //указатель на текущую ячйку в массиве алгоритмов
//  Kol_Alg   : Integer;   //количество заполненных ячеек в массиве Алгоритмов
//   //для организации хранения записей значений ветвей в блоках CASE
//  Blok_CASE : array[1..20000] of TCASEPrcdr; //20000 ячеек для "связанных" записей отдельных ветвей в блоках CASE
//  U_Z_CASE  : Integer;   //указатель на первую "свободную" ячейку в таблице "связанных" записей ветвей блоков CASE
//  U_P_CASE  : Integer;   //указатель на первую "занятую" ячейку в массиве веток CASE
//  U_CASE    : Integer;   //указатель на текущую ячейку в таблице записей ветвей блоков CASE
//  Kol_CASE  : Integer;   //количество заполненных ячеек в массиве веток CASE

  //инициируем все таблицы со "связанными" ячейками (и для хранения Алгоритмов и для ветвей в блоках CASE)

  Kol_Jach_Alg := 5000;  //пока резервируем 5000 ячеек

   //сначала пробегаем по массиву ячеек для хранения Алгоритмов
  for int_i:=0 to Kol_Jach_Alg do
   begin
    Blok_Alg[int_i].ID          := 0;
    Blok_Alg[int_i].IM          := '';
    Blok_Alg[int_i].DLN_IM      := '';
    Blok_Alg[int_i].P1          := '';
    Blok_Alg[int_i].P2          := '';
    Blok_Alg[int_i].U1          := '';
    Blok_Alg[int_i].P3          := '';
    Blok_Alg[int_i].NC          := 0;
    Blok_Alg[int_i].P4          := '';
    Blok_Alg[int_i].U2          := '';
    Blok_Alg[int_i].P5          := '';
    Blok_Alg[int_i].P6          := '';
    Blok_Alg[int_i].P7          := '';
    Blok_Alg[int_i].P8          := '';
    Blok_Alg[int_i].I           := 0;
    Blok_Alg[int_i].U_1_CASE    := 0;
    Blok_Alg[int_i].Flg_Zanat   := False;
//    Blok_Alg[int_i].Next_P      := int_i+1;     //указатель на следующую "пустую" ячейку
     //инициируем цепочку "занятых" ячеек (пока нулями)
    Blok_Alg[int_i].Next_P      := 0;           //указатель на следующую занятую ячейку
    Blok_Alg[int_i].Pred_P      := 0;           //указатель на предыдущую занятую ячейку
     //инициируем цепочку связанных "пустых" ячеек
    Blok_Alg[int_i].Next_Z      := int_i+1;     //указатель на следующую "пустую" ячейку
   end;

   Blok_Alg[Kol_Jach_Alg].Next_P    := 0; //у последнего элемента ставим указатель на следующую ячейку в 0 - что означает, что цепочка закончилась

    U_Z_Alg := 1;  //ставим указатель на первую свободную ячейку в масииве для хранения Алгоритмов в 1
    U_Alg   := 0;  //указатель на текущую ячейку сбрасываем в 0
    U_P_Alg := 0;  //указатель на первую занятую ячейку в массиве Алгоритмов
    Kol_Alg := 0;  //количество заполненных ячеек в массиве Алгоритмов

   //потом пробегаем по массиву ячеек для хранения ветвей в блоках CASE
  Kol_Jach_CASE := 20000;

  for int_i:=0 to Kol_Jach_CASE do
   begin
//   P_N_Alg      : Integer;   //Номер в массиве Алгоритмов, на который ссылается данная процедура
//   ID_Rod       : Integer;   //ID родительской записи в БД Алгоритмов (в которой описаны эти ветки CASE)
//   Alg_Rod      : Integer;   //номер ячейки с родительским Алгоритмом
    Blok_CASE[int_i].ID          := 0;       //ID этой записи в БД CASE
    Blok_CASE[int_i].N           := 0;       //номер этой ветки
    Blok_CASE[int_i].P           := '';      //выражение либо имя вызываемой процедуры (в этой ветке)
    Blok_CASE[int_i].P_ID        := 0;       //ID записи исполняемой процедуры в БД Алгоритмов
    Blok_CASE[int_i].P_N_Alg     := 0;       //номер ячейки с вызываемой процедурой
    Blok_CASE[int_i].ID_Rod      := 0;       //ID родительского Алгоритма (в которой описана эта ветка CASE)
    Blok_CASE[int_i].Alg_Rod     := 0;       //номер ячейки родительского Алгоритма
    Blok_CASE[int_i].Flg_Zanat   := False;   //флаг занятости
     //цепочка по порядку следования веток (инициируем нулями)
    Blok_CASE[int_i].Next_N      := 0;       //указатель на следующую ячейку в этом же блоке CASE
    Blok_CASE[int_i].Pred_N      := 0;       //указатель на предыдущую ячейку в этом же блоке CASE
     //цепочка следования "полных" ячеек (инициируем нулями)
//    Blok_CASE[int_i].Next_P      := int_i+1; //указатель на следующую "пустую" ячейку
    Blok_CASE[int_i].Next_P      := 0;       //указатель на следующую занятую ячейку
    Blok_CASE[int_i].Pred_P      := 0;       //указатель на предыдущую занятую ячейку
     //цепочка следования "пустых" ячеек
    Blok_CASE[int_i].Next_Z      := int_i+1; //указатель на следующую "пустую" ячейку
   end;
    Blok_CASE[Kol_Jach_CASE].Next_P    := 0; //у последнего элемента ставим указатель на следующую ячейку в 0 - что означает, что цепочка закончилась
    U_Z_CASE := 1;  //ставим указатель на первую свободную ячейку в масииве для хранения ветвей в блоке CASE в 1
    U_CASE   := 0;  //указатель на текущую ячйку сбрасываем в 0
    U_P_CASE := 0;  //указатель на первую занятую ячейку в массиве веток CASE
    Kol_CASE := 0;  //количество заполненных ячеек в массиве CASE

     Edit1.Text := IntToStr(Tb_Prm_Int.FieldByName('KOL_PRC').AsInteger); //выводим на экран количество процедур в БД

  //
  Tb_Alg_Edit;

 end; //конец процедуры создания формы

//======================================================
//при уничтожении формы
procedure TForm1.FormDestroy(Sender: TObject);
 begin
  //Деактивируем подключенные Базы Данных
  Tb_Alg.Active      := False;  //ОТключаем основную базу - Универсальный Алгоритм
  Tb_Im.Active       := False;  //ОТключаем вспомогательную базу - Имя процедуры
  Tb_CASE.Active     := False;  //ОТключаем вспомогательную базу - блок CASE
  Tb_Int.Active      := False;  //ОТключаем базу переменных - Целое
  Tb_Num.Active      := False;  //ОТключаем базу переменных - Вещественное
  Tb_Str.Active      := False;  //ОТключаем базу переменных - Строковое
  Tb_Log.Active      := False;  //ОТключаем базу переменных - Логическое
  Tb_Prm_Int.Active  := False;  //ОТключаем базу - Параметры программы (целочисленные)
 end;

//======================================================
 //при нажатии кнопки "Ввод команды"
procedure TForm1.Bt1Click(Sender: TObject);
 var
//  int_i  : Integer; //для оргнизации циклов
  s      : string;  //строковая переменная
  s1     : string;  //вспомогательная строка
//  s2     : string;  //вспомогательная строка
//  s3     : string;  //вспомогательная строка
  s_Fild : string;  //строка для формирования названия поля
  N_Fild : Integer; //для вычисления номера блока
//  Cmnd   : TCmdEnum; //для хранения введенной комманды
//  Cmnd   : TComand; //для хранения введенной комманды
//  Int_N  : Integer; //введенное число для кол-ва веток CASE
//  Flag   : Boolean; //логическая переменная для учета
//  U_Tek  : Integer; //указатель на текущую ячейку (для поиска)

  //подразумавается, что человек будет вводиь в окно ввода команды (но он моджет и ошибаться)
  //поэтому его нужно проверять
 begin
  N_Fild := 0;     //по началу - номер поля 0 (никуда не указывает)
//  Cmnd   := cmdNihil; //значение команды - НИЧЕГО

   //первое, что мы делаем - переносим введенную человеком команду в диалоговое окно целиком
  s := E1.Text;    //берем текст из строки редактирования (окна ввода)
  s1 := Trim(s);   //удаляем из введенной человеком строки ведущие пробелы
  M1.Lines.Add(s); //и переносим это сообщение в диалоговое окно
  E1.Text := '';   //очищаем строку ввода
{
  //возможные команды: ВЫПОЛНИТЬ-9, СОЗДАТЬ-7, НАЗВАТЬ-7, УСЛОВИЕ-7, ВЕТОК-5, БЛОК-4 (- длина команды)

   //проверяем, не является введенная команда командой ВЫПОЛНИТЬ [процедуру] (самая длинная)
  s1 := Copy(s,1,9); //берем из введенной строки все символы с 1-го до 9-го, и смотрим, что там
   //проверяем, какая команда была введена человеком
  if s1='ВЫПОЛНИТЬ' then //команда ВЫПОЛНИТЬ?
   begin
    Cmnd := cmdVypolnit; //введенная человеком команда - ВЫПОЛНИТЬ
    M1.Lines.Add('Введена команада: ' + s1);  //переносим то, что получилось, в диалоговое окно
    E1.SetFocus;       //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
   end
  else //проверяем другие команды (короче 9-и символов)
   begin
     //проверяем, не является введенная команда командой СОЗДАТЬ [процедуру], или НАЗВАТЬ [процедуру], или УСЛОВИЕ
    s1 := Copy(s,1,7); //берем из введенной строки все символы с 1-го до 7-го, и смотрим, что там
    //проверяем, какая команда была введена человеком
    if s1='СОЗДАТЬ' then //команда СОЗАДТЬ?
     begin
      Cmnd := cmdSozdat; //введенная человеком команда - СОЗДАТЬ
      M1.Lines.Add('Введена команада: ' + s1);  //переносим то, что получилось, в диалоговое окно
      E1.SetFocus;       //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
     end
    else if s1='НАЗВАТЬ' then //команда НАЗВАТЬ?
     begin
      Cmnd := cmdNazvat; //введенная человеком команда - НАЗВАТЬ
      M1.Lines.Add('Введена команада: ' + s1);  //переносим то, что получилось, в диалоговое окно
      E1.SetFocus;       //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
     end
    else if s1='УСЛОВИЕ' then //команда УСЛОВИЕ?
     begin
      Cmnd := cmdUslovie; //введенная человеком команда - УСЛОВИЕ
      M1.Lines.Add('Введена команада: ' + s1);  //переносим то, что получилось, в диалоговое окно
      E1.SetFocus;       //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
     end
    else //если длина введеной команды менее 7-и символов
     begin
       //если длина команды не 7 символов, а меньше
      s1 := Copy(s,1,5); //берем из введенной строки все символы с 1-го до 5-го, и смотрим, что там
       //проверяем, какая команда была введена человеком
      if s1='ВЕТОК' then //команда ВЕТОК?
       begin
        Cmnd := cmdVetok; //введенная человеком команда - ВЕТОК
        M1.Lines.Add('Введена команада: ' + s1);  //переносим то, что получилось, в диалоговое окно
        E1.SetFocus;       //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
       end
      else if s1='ВЕТКА' then //команда ВЕТКА
       begin
        Cmnd := cmdVetka; //введенная человеком команда - ВЕТКА
        M1.Lines.Add('Введена команада: ' + s1);  //переносим то, что получилось, в диалоговое окно
        E1.SetFocus;       //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
       end
      else //если длина введеной команды менее 5-и символов
       begin
         //если длина команды не 5 символов, а меньше
        s1 := Copy(s,1,4); //берем из введенной строки все символы с 1-го до 4-го, и смотрим, что там
         //проверяем, какая команда была введена человеком
        if s1='БЛОК' then //команда БЛОК?
         begin
          Cmnd := cmdBlok; //введенная человеком команда - БЛОК
          M1.Lines.Add('Введена команада: ' + s1);  //переносим то, что получилось, в диалоговое окно
          E1.SetFocus;       //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
         end;

       // !!! здесь будет проверка на другие введенные команды !!!

       end; //конец условия, что длина введенной команды меньше чем 5 символов
     end; //конец условия, что длина введенной команды меньше чем 7 символов
   end; //конец условия, что длина введенной команды меньше чем 9 символов

}
   //обрабатываем различные команды введенные человеком
//  case Cmnd of
  case GetCmd(s) of

    //---------------------------------------------------------
   cmdSozdat : //обрабатываем команду СОЗДАТЬ [процедуру]
    begin
     cmd_Sozdat(s); //процедура СОЗДАТЬ новый Алгоритм (возможно введено новое имя для этого алгоритма)
    end; //конец обработки команды СОЗДАТЬ (процедуру) (с присвоением нового имени, если таковое было введено)

    //---------------------------------------------------------
   cmdNazvat : //обрабатываем команду НАЗВАТЬ [процедуру] - дать ей своё собственное имя
    begin
     cmd_Nazvat(s); //если была введена команда НАЗВАТЬ (процедуру) - введено новое имя для нее
    end; //конец обработки команды НАЗВАТЬ (процедуру)

    //---------------------------------------------------------
   cmdVetok : //обрабатываем команду Vetok - указываем, сколько ветвей будет в блоке CASE у этого алгоритма
    begin
     cmd_Vetok(s); //если была введена команда NCASE (задать количество ветвей в блоке CASE)
    end; //конец обработки команды NCASE (указываем количество ветвей в блоке CASE)

   cmdVypolnit:
   begin
     cmd_Vypolnit(s);
   end;

   cmdUslovie:
   begin
     cmd_Uslovie(s);
   end;

    //---------------------------------------------------------
   cmdBlok : //обрабатываем команду БЛОК - заполняем тот или иной блок содержимым
    begin
      {TODO: Оформить в отдельную процедуру cmd_Blok(s)}
      cmd_Blok(s);
      Exit;
      //берем из исходной введенной человеком строки оставшуюся после команды БЛОК часть
     s1 := Copy(s,5,100); //берем из введенной строки все символы с 5-го и до конца (100 символов макс)
     s1 := Trim(s1);      //удаляем пробелы вначале и в конце получившейся строки
     M1.Lines.Add('Введенное содержимое: ' + s1);    //переносим то, что получилось, в диалоговое окно
     E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)

       //смотрим, к какому именно блоку идет обращение (либо P1, P2 и т.д., либо просто 1, 2... - номер блока)
      s := Copy(s1,1,1); //берем первый символ из этой строки

      //вводится ли название блока в виде Р1, Р2 и т.д.
     if (s='P') OR (s='Р') OR (s='П') then //если первый символ английская 'P', или русская "Р", или русская "П"
      begin //все в порядке - это символ "Р" англ, или "Р" руск, или "П" руск
         //тогда берем второй символ
        s := Copy(s1,2,1); //берем второй символ из этой же строки
         //проверяем, не цифра ли это
       {TODO: функция проверяет символ, является ли он числом}
       if (s='1') OR (s='2') OR (s='3') OR (s='4') OR (s='5') OR (s='6') OR (s='7') OR (s='8') then
        begin //если следующий символ - это цифра от 1 до 8, то значит, все в порядке - блок указан верно
          //формируем название поля БД Алгоритмов (правильно)
         s_Fild := 'P' + s; //получаем название поля Pn, где n - это введенный номер
            //проверим за счет третьего символа (должен быть пробел)
          s := Copy(s1,3,1); //берем третий символ из этой же строки
         if (s=' ') OR (s='') then //если третий символ "пробел" (или "пустой символ"), то все в порядке - введен номер блока
          begin
           M1.Lines.Add('Номер блока: ' + s_Fild);    //переносим то, что получилось, в диалоговое окно
           E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
            //берем оставшуюся часть строки (если есть)
           s1 := Copy(s1,3,100); //берем из введенной строки все символы с 3-го и до конца (100 символов макс)
           s1 := Trim(s1);      //удаляем пробелы вначале и в конце получившейся строки
           M1.Lines.Add('Введенное содержимое: ' + s1);    //переносим то, что получилось, в диалоговое окно
           E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
            //проверим, есть ли там чот-нибудь (не пустая ли строка)
           if NOT (s1='') then //если не пусто
            begin
              //заполняем блок введенным содержимым
             Tb_Alg.Edit;  //Открывает БД имен процедур для редактирования
             Tb_Alg.FieldByName(s_Fild).AsString   := s1;   //заносим введенное человеком содержимое в указанный блок
             Tb_Alg.Post;  //подтверждаем сделанные изменения
            end
           else //содержимого нет
            begin
             M1.Lines.Add('Нет содержимого блока');    //вывод сообщения, что у блока нет содержимого
             E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
            end;
          end   //конец формирования правильного номера блока и записи в него
         else
          begin
           M1.Lines.Add('Неправильно введен номер блока');    //вывод сообщения, что номер блока написан неправильно
           E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
          end;  //конец вывода сообщения об ошибке ввода номера блока
        end //конец проверки, что второй символ - это цифра от 1 лдо 8 (номер блока типа Рn)
       else  //второй символ - это не цифра, значит номер блока введен неправильно
        begin
         M1.Lines.Add('Неправильно введен номер блока');    //вывод сообщения, что номер блока написан неправильно
         E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
        end; //конец вывода сообщения об ошибке ввода номера блока
      end //конец проверки на первый символ "Р" англ, или "Р" руск, или "П" руск

      //вводится номер блока CASE, типа N1, N2 (англ) или Н1, Н2 (руск)
     else if (s='N') OR (s='Н') then //если первый символ английская 'N', или русская "Н"
      begin //все в порядке (в блоках CASE может быть до 255 вариантов, значит номер может быть от 1 до 255)
        s := Copy(s1,2,1); //берем второй символ из этой же строки
       if (s='1') OR (s='2') OR (s='3') OR (s='4') OR (s='5') OR (s='6') OR (s='7') OR (s='8') OR (s='9') OR (s='0') then
        begin //если следующий символ - это цифра от 1 до 0, то значит, все в порядке
          //формируем название поля (правильно)
         s_Fild := 'N' + s;     //получаем название поля Nn, где n - это введенный номер
         N_Fild := StrToInt(s); //преобразуем символьное значение номера в числовое
            //смотрим третий символ (что там: цифра или пробел)
          s := Copy(s1,3,1); //берем третий символ из этой же строки
         if (s=' ') OR (s='') then //если третий символ "пробел" (или "пустой символ"), то все в порядке - введен номер блока
          begin
           M1.Lines.Add('Номер блока: ' + s_Fild);    //переносим то, что получилось, в диалоговое окно
           E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)

             //для блоков CASE нужно проверять на превышение размера (не больше ли NCASE)
           if N_Fild<=Alg.NC then //если введенное человеком число меньше или равно заявленному количеству ветвей в блоке CASE
            begin
              //берем оставшуюся часть строки (если есть)
             s1 := Copy(s1,3,100); //берем из введенной строки все символы с 3-го и до конца (100 символов макс)
             s1 := Trim(s1);      //удаляем пробелы вначале и в конце получившейся строки
             M1.Lines.Add('Введенное содержимое: ' + s1);    //переносим то, что получилось, в диалоговое окно
             E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
              //проверим, есть ли там что-нибудь (не пустая ли строка)
             if NOT (s1='') then //если не пусто
              begin
                //берем номер записи для данной ветки CASE
//               ID_CASE := Alg.MCASE[N_Fild].ID; //берем ID записи в БД CASE для этой ветки
//               s_ID    := IntToStr(ID_CASE);    //преобразуем это ID в строку
                //позиционируем указатель на эту запись в БД CASE
               Tb_CASE.Locate('ID',s_ID,[]); //ищем в БД запись с этим ID (устанавливаем указатель на неё)
                //заполняем блок введенным содержимым
               Tb_CASE.Edit;  //Открывает БД имен процедур для редактирования
               Tb_CASE.FieldByName('P').AsString   := s1;   //заносим введенное человеком содержимое в указанный блок
               Tb_CASE.Post;  //подтверждаем сделанные изменения
                //сразу же заполняем и структуру Универсального Алгоритма в памяти
//               Alg.MCASE[N_Fild].Prc := s1;  //заносим содержимое
              end
             else //содержимого нет
              begin
               M1.Lines.Add('Нет содержимого блока');    //вывод сообщения, что у блока нет содержимого
               E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
              end;
            end //конец проверки, что введенный номер меньше или равен заявленному количеству ветвей в блоке CASE
           else //введенное человеком число больше заявленного количества ветвей в блоке CASE
            begin
             M1.Lines.Add('Недопустимый номер блока CASE');    //вывод сообщения, что это недопустимый номер для блока CASE
             E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
            end;
          end //конец формирования правильного номера блока (из одной цифры) и записи в него
         else //третий символ - не пробел (проверим, не цифра ли это - продолжение номера блока)
          begin
           if (s='1') OR (s='2') OR (s='3') OR (s='4') OR (s='5') OR (s='6') OR (s='7') OR (s='8') OR (s='9') OR (s='0') then
            begin //если третий символ - это цифра от 1 до 0, то значит, все в порядке
              //формируем название поля (правильно)
             s_Fild := s_Fild + s; //получаем название поля Nn, где n - это введенный номер (добавляем к уже имеющемуся номеру еще одну цифру)
             N_Fild := N_Fild*10 + StrToInt(s); //преобразуем символьное значение номера в числовое (добавляем еще одну цифру)
                //смотрим четвертый символ (что там: цифра или пробел)
              s := Copy(s1,4,1); //берем четвертый символ из этой же строки
             if (s=' ') OR (s='') then //если четвертый символ "пробел" (или "пустой символ"), то все в порядке - введен номер блока
              begin
               M1.Lines.Add('Номер блока: ' + s_Fild);    //переносим то, что получилось, в диалоговое окно
               E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)

                 //для блоков CASE нужно проверять на превышение размера (не больше ли NCASE)
               if N_Fild<=Alg.NC then //если введенное человеком число меньше или равно заявленному количеству ветвей в блоке CASE
                begin
                  //берем оставшуюся часть строки (если есть)
                 s1 := Copy(s1,4,100); //берем из введенной строки все символы с 4-го и до конца (100 символов макс)
                 s1 := Trim(s1);      //удаляем пробелы вначале и в конце получившейся строки
                 M1.Lines.Add('Введенное содержимое: ' + s1);    //переносим то, что получилось, в диалоговое окно
                 E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
                  //проверим, есть ли там что-нибудь (не пустая ли строка)
                 if NOT (s1='') then //если не пусто
                  begin
                    //берем номер записи для данной ветки CASE
//                   ID_CASE := Alg.MCASE[N_Fild].ID; //берем ID записи в БД CASE для этой ветки
                    //позиционируем указатель на эту запись в БД CASE
                   Tb_CASE.Locate('ID',s_ID,[]); //ищем в БД запись с этим ID (устанавливаем указатель на неё)
                    //заполняем блок введенным содержимым
                   Tb_CASE.Edit;  //Открывает БД имен процедур для редактирования
                   Tb_CASE.FieldByName('P').AsString   := s1;   //заносим введенное человеком содержимое в указанный блок
                   Tb_CASE.Post;  //подтверждаем сделанные изменения
                    //сразу же заполняем и структуру Универсального Алгоритма в памяти
//                   Alg.MCASE[N_Fild].Prc := s1;  //заносим содержимое
                  end
                 else //содержимого нет
                  begin
                   M1.Lines.Add('Нет содержимого блока');    //вывод сообщения, что у блока нет содержимого
                   E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
                  end;
                end //конец проверки, что введенный номер меньше или равен заявленному количеству ветвей в блоке CASE
               else //введенное человеком число больше заявленного количества ветвей в блоке CASE
                begin
                 M1.Lines.Add('Недопустимый номер блока CASE');    //вывод сообщения, что это недопустимый номер для блока CASE
                 E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
                end;
              end //конец формирования правильного номера блока (из двух цифр) и записи в него

             else //четвертый символ - не пробел (проверим, не цифра ли это - продолжение номера блока)
              begin
               if (s='1') OR (s='2') OR (s='3') OR (s='4') OR (s='5') OR (s='6') OR (s='7') OR (s='8') OR (s='9') OR (s='0') then
                begin //если четвертый символ - это цифра от 1 до 0, то значит, все в порядке
                  //формируем название поля (правильно)
                 s_Fild := s_Fild + s; //получаем название поля Nn, где n - это введенный номер (добавляем к уже имеющемуся номеру еще одну цифру)
                 N_Fild := N_Fild*10 + StrToInt(s); //преобразуем символьное значение номера в числовое (добавляем еще одну цифру)
                    //смотрим пятый символ (что там: цифра или пробел)
                  s := Copy(s1,5,1); //берем пятыый символ из этой же строки
                 if (s=' ') OR (s='') then //если пятый символ "пробел" (или "пустой символ"), то все в порядке - введен номер блока
                  begin
                   M1.Lines.Add('Номер блока: ' + s_Fild);    //переносим то, что получилось, в диалоговое окно
                   E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)

                     //для блоков CASE нужно проверять на превышение размера (не больше ли NCASE)
                   if N_Fild<=Alg.NC then //если введенное человеком число меньше или равно заявленному количеству ветвей в блоке CASE
                    begin
                      //берем оставшуюся часть строки (если есть)
                     s1 := Copy(s1,5,100); //берем из введенной строки все символы с 5-го и до конца (100 символов макс)
                     s1 := Trim(s1);      //удаляем пробелы вначале и в конце получившейся строки
                     M1.Lines.Add('Введенное содержимое: ' + s1);    //переносим то, что получилось, в диалоговое окно
                     E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
                      //проверим, есть ли там что-нибудь (не пустая ли строка)
                     if NOT (s1='') then //если не пусто
                      begin
                        //берем номер записи для данной ветки CASE
//                       ID_CASE := Alg.MCASE[N_Fild].ID; //берем ID записи в БД CASE для этой ветки
                        //позиционируем указатель на эту запись в БД CASE
                       Tb_CASE.Locate('ID',s_ID,[]); //ищем в БД запись с этим ID (устанавливаем указатель на неё)
                        //заполняем блок введенным содержимым
                       Tb_CASE.Edit;  //Открывает БД имен процедур для редактирования
                       Tb_CASE.FieldByName('P').AsString   := s1;   //заносим введенное человеком содержимое в указанный блок
                       Tb_CASE.Post;  //подтверждаем сделанные изменения
                        //сразу же заполняем и структуру Универсального Алгоритма в памяти
//                       Alg.MCASE[N_Fild].Prc := s1;  //заносим содержимое
                      end
                     else //содержимого нет
                      begin
                       M1.Lines.Add('Нет содержимого блока');    //вывод сообщения, что у блока нет содержимого
                       E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
                      end;
                    end //конец проверки, что введенный номер меньше или равен заявленному количеству ветвей в блоке CASE
                   else //введенное человеком число больше заявленного количества ветвей в блоке CASE
                    begin
                     M1.Lines.Add('Недопустимый номер блока CASE');    //вывод сообщения, что это недопустимый номер для блока CASE
                     E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
                    end;
                  end //конец формирования правильного номера блока (из двух цифр) и записи в него
                 else //пятый символ не пробел - номер введен неправильно
                  begin
                   M1.Lines.Add('Неправильно введен номер блока');    //вывод сообщения, что номер блока написан неправильно
                   E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
                  end; //конец вывода сообщения об ошибке ввода номера блока
                end //конец проверки четвертого символа на цифру
               else //если четвертый символ не цифра и (не пробел), то значит был неправильно введен номер блока
                begin
                 M1.Lines.Add('Неправильно введен номер блока');    //вывод сообщения, что номер блока написан неправильно
                 E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
                end; //конец вывода сообщения об ошибке ввода номера блока
              end; //конец условия, что четвертый символ - не пробел
            end //конец условия, что третий символ - это цифра
           else //если третий символ не цифра и (не пробел), то значит был неправильно введен номер блока
            begin
             M1.Lines.Add('Неправильно введен номер блока');    //вывод сообщения, что номер блока написан неправильно
             E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
            end; //конец вывода сообщения об ошибке ввода номера блока
          end //конец условия, что третий символ - не пробел
        end //конец условия, что второй символ - это цифра
       else //если второй символ - это не цифра (значит, номер введен неправильно)
        begin
         M1.Lines.Add('Неправильно введен номер блока');    //вывод сообщения, что номер блока написан неправильно
         E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
        end; //конец вывода сообщения об ошибке ввода номера блока
      end //конец проверки на первый символ "N" англ, или "Н" руск

      //номер блока указывается просто одной цифрой (от 1 до 8)
     else if (s='1') OR (s='2') OR (s='3') OR (s='4') OR (s='5') OR (s='6') OR (s='7') OR (s='8') then
      begin //все в порядке - это цифра
        //формируем название поля БД Алгоритмов (правильно)
       s_Fild := 'P' + s; //получаем название поля Pn, где n - это введенный номер
          //проверим за счет второго символа (должен быть пробел)
        s := Copy(s1,2,1); //берем второй символ из этой же строки
       if (s=' ') OR (s='') then //если второй символ "пробел" (или "пустой символ"), то все в порядке - введен номер блока
        begin
         M1.Lines.Add('Номер блока: ' + s_Fild);    //переносим то, что получилось, в диалоговое окно
         E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
          //берем оставшуюся часть строки (если есть)
         s1 := Copy(s1,2,100); //берем из введенной строки все символы с 2-го и до конца (100 символов макс)
         s1 := Trim(s1);      //удаляем пробелы вначале и в конце получившейся строки
         M1.Lines.Add('Введенное содержимое: ' + s1);    //переносим то, что получилось, в диалоговое окно
         E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
          //проверим, есть ли там что-нибудь (не пустая ли строка)
         if NOT (s1='') then //если не пусто
          begin
            //для блоков CASE нужно проверять на превышение размера (не больше ли NCASE)
           if N_Fild<=Alg.NC then //если введенное человеком число меньше или равно заявленному количеству ветвей в блоке CASE
            begin
              //берем номер записи для данной ветки CASE
//             ID_CASE := Alg.MCASE[N_Fild].ID; //берем ID записи в БД CASE для этой ветки
              //позиционируем указатель на эту запись в БД CASE
             Tb_CASE.Locate('ID',s_ID,[]); //ищем в БД запись с этим ID (устанавливаем указатель на неё)
              //заполняем блок введенным содержимым
             Tb_CASE.Edit;  //Открывает БД имен процедур для редактирования
             Tb_CASE.FieldByName('P').AsString   := s1;   //заносим введенное человеком содержимое в указанный блок
             Tb_CASE.Post;  //подтверждаем сделанные изменения
              //сразу же заполняем и структуру Универсального Алгоритма в памяти
//             Alg.MCASE[N_Fild].Prc := s1;  //заносим содержимое
            end
           else //введенное человеком число больше заявленного количества ветвей в блоке CASE
            begin
             M1.Lines.Add('Недопустимый номер блока CASE');    //вывод сообщения, что это недопустимый номер для блока CASE
             E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
            end;
          end //конец условия, что содержимое не пустое
         else //содержимого нет
          begin
           M1.Lines.Add('Нет содержимого блока');    //вывод сообщения, что у блока нет содержимого
           E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
          end;
        end   //конец формирования правильного номера блока и записи в него
       else
        begin
         M1.Lines.Add('Неправильно введен номер блока');    //вывод сообщения, что номер блока написан неправильно
         E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
        end;  //конец вывода сообщения об ошибке ввода номера блока
      end //конец проверки на написание номера блока только одной цифрой

      //все остальные варианты означают, что был неправильно набран номер блока
     else //не было ни цифры, ни символов "Р" или "Н" (значит, номер блока указан неверно)
      begin
       M1.Lines.Add('Неправильно введен номер блока');    //вывод сообщения, что номер блока написан неправильно
       E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
      end;  //конец вывода сообщения об ошибке ввода номера блока
    end; //конец обработки команды БЛОК

   end; //конец блока CASE - обработки различных введеных человеком команд

 end; //конец процедуры - обработки ввода команды в командную строку

//======================================================
//
procedure TForm1.Tb_Alg_Edit;
begin
  E_Dln_Str_P1.Text := Tb_Alg.FieldByName('P1').AsString;
  E_Dln_Str_P2.Text := Tb_Alg.FieldByName('P2').AsString;
  E_Dln_Str_P3.Text := Tb_Alg.FieldByName('P3').AsString;
  E_Dln_Str_P4.Text := Tb_Alg.FieldByName('P4').AsString;
  E_Dln_Str_P5.Text := Tb_Alg.FieldByName('P5').AsString;
  E_Dln_Str_P6.Text := Tb_Alg.FieldByName('P6').AsString;
  E_Dln_Str_P7.Text := Tb_Alg.FieldByName('P7').AsString;
  E_Dln_Str_P8.Text := Tb_Alg.FieldByName('P8').AsString;
  E_Dln_Str_U1.Text := Tb_Alg.FieldByName('U1').AsString;
  E_Dln_Str_U2.Text := Tb_Alg.FieldByName('U2').AsString;
end;

//======================================================
 //при включении фильтрации в этой таблице - будут отбираться лишь те записи, которые совпадают с ID родителя
procedure TForm1.Tb_CASEFilterRecord(DataSet: TDataSet;   var Accept: Boolean);
 begin
  Accept:= (DataSet['ID_ROD'] = ID_Rod); //отбор по ID родительской записи в БД Алгоритмов
 end;

//======================================================
 //фильтрация в БД имен процедур
procedure TForm1.Tb_ImFilterRecord(DataSet: TDataSet; var Accept: Boolean);
 begin
  Accept:= (DataSet['ID_ALG'] = ID_Rod); //отбор по ID родительской записи в БД Алгоритмов
 end;

 //======================================================
 //при кликаньи мышкой по Навигатору может быть только перемещение по БД Алгоритмов
procedure TForm1.DBNav1Click(Sender: TObject; Button: TNavigateBtn);
 begin
  //указатель стоит на текущей записи в БД Алгоритмов
  ID_Rod := Tb_Alg.FieldByName('ID').AsInteger; //берем ID родителя (текущая запись)

   //фильтруем записи в БД CASE в заисимости от ID родительской БД Алгоритмов
  Tb_CASE.Filtered := False; //выключаем (на время) фильтрацию
  Tb_CASE.Filtered := True;  //включаем фильтрацию

   //фильтруем записи в БД имен процедур в заисимости от ID родительской БД Алгоритмов
  Tb_Im.Filtered := False; //выключаем (на время) фильтрацию
  Tb_Im.Filtered := True;  //включаем фильтрацию

   //переносим название (имя процедуры, если есть) в строку Едит
  s_Im := Tb_Im.FieldByName('DLN_IM').AsString; //берем имя процедуры (если оно там есть)
   //проверяем, что получилось
  if s_Im = '' then //если там ничего не было
   begin //очищаем строку вывода имени процедуры
    L_Im.Caption := ''; //пусто
   end
  else  //имя у процедуры есть
   begin
    L_Im.Caption := s_Im; //переносим полученное имя процедуры в окно строки
   end;

  //
  Tb_Alg_Edit;
 end;

// Выполнить алгоритм AlgName
procedure TForm1.DoCmdRun(const AlgName: string);
begin
  ShowMessage(Format('ВЫПОЛНИТЬ АЛГОРИТМ: %s!', [AlgName]));
end;

//конец процедуры TForm1.DBNav1Click - при клике мышкой по Навигатору

// Редактор значений тек. строки таблицы для ячеек от P1 и до P8, а также U1 и U2
procedure TForm1.E_Dln_Str_P1Change(Sender: TObject);
begin
  {TODO: Эти куски кода заменить на один метод. Возможно задействовать свойство Tag}
  Tb_Alg.Edit;
  Tb_Alg.FieldByName('P1').AsString := E_Dln_Str_P1.Text;
  Tb_Alg.Post;
end;

procedure TForm1.E_Dln_Str_P2Change(Sender: TObject);
begin
  Tb_Alg.Edit;
  Tb_Alg.FieldByName('P2').AsString := E_Dln_Str_P2.Text;
  Tb_Alg.Post;
end;

procedure TForm1.E_Dln_Str_P3Change(Sender: TObject);
begin
  Tb_Alg.Edit;
  Tb_Alg.FieldByName('P3').AsString := E_Dln_Str_P3.Text;
  Tb_Alg.Post;
end;

procedure TForm1.E_Dln_Str_P4Change(Sender: TObject);
begin
  Tb_Alg.Edit;
  Tb_Alg.FieldByName('P4').AsString := E_Dln_Str_P4.Text;
  Tb_Alg.Post;
end;

procedure TForm1.E_Dln_Str_P5Change(Sender: TObject);
begin
  Tb_Alg.Edit;
  Tb_Alg.FieldByName('P5').AsString := E_Dln_Str_P5.Text;
  Tb_Alg.Post;
end;

procedure TForm1.E_Dln_Str_P6Change(Sender: TObject);
begin
  Tb_Alg.Edit;
  Tb_Alg.FieldByName('P6').AsString := E_Dln_Str_P6.Text;
  Tb_Alg.Post;
end;

procedure TForm1.E_Dln_Str_P7Change(Sender: TObject);
begin
  Tb_Alg.Edit;
  Tb_Alg.FieldByName('P7').AsString := E_Dln_Str_P7.Text;
  Tb_Alg.Post;
end;

procedure TForm1.E_Dln_Str_P8Change(Sender: TObject);
begin
  Tb_Alg.Edit;
  Tb_Alg.FieldByName('P8').AsString := E_Dln_Str_P8.Text;
  Tb_Alg.Post;
end;

procedure TForm1.E_Dln_Str_U1Change(Sender: TObject);
begin
  Tb_Alg.Edit;
  Tb_Alg.FieldByName('U1').AsString := E_Dln_Str_U1.Text;
  Tb_Alg.Post;
end;

procedure TForm1.E_Dln_Str_U2Change(Sender: TObject);
begin
  Tb_Alg.Edit;
  Tb_Alg.FieldByName('U2').AsString := E_Dln_Str_U2.Text;
  Tb_Alg.Post;
end;

//======================================================
 //процедура СОЗДАТЬ новый Алгоритм (возможно введено новое имя для этого алгоритма)
procedure cmd_Sozdat(S : String); //если была введена команда СОЗДАТЬ (процедуру), и возможно было введено новое имя для нее
 var
  s1     : String;  //временная строка
  int_ID : Integer; //для взятия ID текущей записи

 begin
   //генерируем новое условное (внутреннее) имя для этой создаваемой процедуры
  Kol_Proc := Kol_Proc + 1; //увеличиваем счетчик созданных процедур
  Im_Proc  := 'PRC' + IntToStr(Kol_Proc); //получается имя типа PRCN, где N - числа от 1 до ...
   //сохраняем в БД параметров изменения количества процедур
  Form1.Tb_Prm_Int.Edit;
   Form1.Tb_Prm_Int.FieldByName('KOL_PRC').AsInteger  := Kol_Proc;        //новое значение количества созданных процедур-алгоритмов
  Form1.Tb_Prm_Int.Post;

   //создаем новую процедуру (добавляем новую запись в БД Алгоритмов)
  Form1.Tb_Alg.Insert; //добавляем (создаем) новую запись (пустую)
   Form1.Tb_Alg.FieldByName('IM').AsString      := Im_Proc;  //присваиваем условное имя этой процедуре
   Form1.Tb_Alg.FieldByName('IM_ID').AsInteger  := 0;        //ссылка на запись с длинным именем в БД имен процедур
   Form1.Tb_Alg.FieldByName('P1').AsString      := 'Null';   //пустая процедура
   Form1.Tb_Alg.FieldByName('P1_ID').AsInteger  := 0;        //никуда не указывает
   Form1.Tb_Alg.FieldByName('P2').AsString      := 'Null';   //пустая процедура
   Form1.Tb_Alg.FieldByName('P2_ID').AsInteger  := 0;        //никуда не указывает
   Form1.Tb_Alg.FieldByName('U1').AsString      := 'ИСТИНА'; //изначально условие всегда истинное по-умолчанию
   Form1.Tb_Alg.FieldByName('P3').AsString      := 'Null';   //пустая процедура
   Form1.Tb_Alg.FieldByName('P3_ID').AsInteger  := 0;        //никуда не указывает
   Form1.Tb_Alg.FieldByName('NC').AsInteger     := 1;        //по умолчанию в блоке CASE всего одна ветвь
   Form1.Tb_Alg.FieldByName('NAME').AsString    := '';       //по умолчанию пустое имя для пользовательской переменной
   Form1.Tb_Alg.FieldByName('TIP').AsInteger    := 0;        //по умолчанию тип этой переменной не задан
   Form1.Tb_Alg.FieldByName('SPISOK').AsString  := '';       //по умолчанию список значений этой переменной тоже пуст
   Form1.Tb_Alg.FieldByName('P4').AsString      := 'Null';   //пустая процедура
   Form1.Tb_Alg.FieldByName('P4_ID').AsInteger  := 0;        //никуда не указывает
   Form1.Tb_Alg.FieldByName('U2').AsString      := 'ИСТИНА'; //изначально условие всегда истинное по-умолчанию
   Form1.Tb_Alg.FieldByName('P5').AsString      := 'Null';   //пустая процедура
   Form1.Tb_Alg.FieldByName('P5_ID').AsInteger  := 0;        //никуда не указывает
   Form1.Tb_Alg.FieldByName('P6').AsString      := 'Null';   //пустая процедура
   Form1.Tb_Alg.FieldByName('P6_ID').AsInteger  := 0;        //никуда не указывает
   Form1.Tb_Alg.FieldByName('P7').AsString      := 'Null';   //пустая процедура
   Form1.Tb_Alg.FieldByName('P7_ID').AsInteger  := 0;        //никуда не указывает
   Form1.Tb_Alg.FieldByName('P8').AsString      := 'Null';   //пустая процедура
   Form1.Tb_Alg.FieldByName('P8_ID').AsInteger  := 0;        //никуда не указывает
  Form1.Tb_Alg.Post; //подтверждаем сделанные изменения

    ID_Rod := Form1.Tb_Alg.FieldByName('ID').AsInteger; //берем ID родителя (текущая запись в БД Алгоритмов)

   //сразу же создаем запись и в БД для блока CASE
  Form1.Tb_CASE.Insert; //добавляем (создаем) новую запись (пустую)
   Form1.Tb_CASE.FieldByName('ID_ROD').AsInteger  := ID_Rod;  //запоминаем ID родительской записи в БД Алгоритмов
   Form1.Tb_CASE.FieldByName('NCASE').AsInteger   := 1;       //номер первой ветки блока CASE - 1
   Form1.Tb_CASE.FieldByName('P').AsString        := 'Null';  //пустая процедура
   Form1.Tb_CASE.FieldByName('P_ID').AsInteger    := 0;       //указываем на несуществующую процедуру
  Form1.Tb_CASE.Post; //подтверждаем сделанные изменения

     //производим отбор строк, которые относятся к текущему алгоритму (ID_ROD = ID текущей записи в БД Alg)
   //включаем фильтрацию
  Form1.Tb_CASE.Filtered := True;
  ID_CASE := Form1.Tb_CASE.FieldByName('ID').AsInteger; //берем ID записи из БД CASE для этой ветки

   //смотрим, не было ли введено вместе с командой еще и имя для создаваемой процедуры
  s1 := Copy(s,8,100); //берем из введенной строки все символы с 8-го и до конца (100 симв макс), и смотрим, что там
  s1 := Trim(s1);      //удаляем ведущий пробелы

    //проверяем, не пустая ли это строка
  if NOT (s1='') then //если строка не пустая (то есть, было введено имя для процедуры)
   begin
     //выводим имя в Мемо-поле
    Form1.M1.Lines.Add('Введенное имя: ' + s1);    //переносим то, что получилось, в диалоговое окно
    Form1.E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
     //создаем имя для этой процедуры и заносим его в БД имен процедур
    s_ID   := IntToStr(ID_Rod);  //преобразуем ID_Rod в текст
     //добавляем запись в БД имен процедур и присваиваем новой процедуре введенное имя
    Form1.Tb_Im.Insert; //добавляем (создаем) новую запись (пустую)
     Form1.Tb_Im.FieldByName('ID_ALG').AsInteger  := ID_Rod;  //запоминаем ID родительской записи в БД Алгоритмов
     Form1.Tb_Im.FieldByName('DLN_IM').AsString   := s1;      //а сюда - введенное человеком имя процедуры
    Form1.Tb_Im.Post; //подтверждаем сделанные изменения

     //переносим имя этой процедуры в строку Заголовка
    Form1.L_Im.Caption := s1; //переносим полученное имя процедуры в Заголовок - окно текстовой строки

     //запоминаем ID сделанной записи длинного имени в БД Алгоритмов
    int_ID := Form1.Tb_Im.FieldByName('ID').AsInteger; //берем ID этой записи в БД длинных имен
     Form1.Tb_Alg.Edit; //открываем на редактирование БД Алгоритмов
      Form1.Tb_Alg.FieldByName('IM_ID').AsInteger := int_ID; //делаем запись
     Form1.Tb_Alg.Post; //подтверждаем изменения

   end; //конец ввода нового названия для процедуры

   //все записи во все БД сделаны, осталось заполнить соответсвующие структуры в массивах ячеек
//     Zap_Tek_Alg(); //процедура заполнения ячеек массивов по текущей записи БД
   //(для новой можно сделать проще, поэтому оставляем здесь)
    //записываем в первую текущую "пустую" ячейку - на неё показывает указатель
   U_Alg := U_Z_Alg; //берем указатель на первую (текущую) "свободную" ячейку в массиве Алгоритмов
  Blok_Alg[U_Alg].ID        := ID_Rod;   //ID записи в БД Алгоритмов
  Blok_Alg[U_Alg].IM        := Im_Proc;  //даем сгенерированное программой имя, типа PRCN
  Blok_Alg[U_Alg].DLN_IM    := s1;       //и присваиваем имя даное человеком, если есть
  Blok_Alg[U_Alg].P1        := 'Null';   //пустая процедура
  Blok_Alg[U_Alg].P1_N      := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].P1_ID     := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].P2        := 'Null';   //пустая процедура
  Blok_Alg[U_Alg].P2_N      := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].P2_ID     := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].U1        := 'ИСТИНА'; //изначально условие всегда истинное по-умолчанию
  Blok_Alg[U_Alg].P3        := 'Null';   //пустая процедура
  Blok_Alg[U_Alg].P3_N      := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].P3_ID     := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].NC        := 1;        //по умолчанию в блоке CASE всего одна ветвь
  Blok_Alg[U_Alg].NAME      := '';       //по умолчанию пустое имя переменной
  Blok_Alg[U_Alg].TIP       := 0;        //по умолчанию нет типа этой переменной: '0' - нет значения
  Blok_Alg[U_Alg].SPISOK    := '';       //по умолчанию пустой список значений у этой переменной
  Blok_Alg[U_Alg].P4        := 'Null';   //пустая процедура
  Blok_Alg[U_Alg].P4_N      := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].P4_ID     := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].U2        := 'ИСТИНА'; //изначально условие всегда истинное по-умолчанию
  Blok_Alg[U_Alg].P5        := 'Null';   //пустая процедура
  Blok_Alg[U_Alg].P5_N      := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].P5_ID     := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].P6        := 'Null';   //пустая процедура
  Blok_Alg[U_Alg].P6_N      := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].P6_ID     := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].P7        := 'Null';   //пустая процедура
  Blok_Alg[U_Alg].P7_N      := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].P7_ID     := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].P8        := 'Null';   //пустая процедура
  Blok_Alg[U_Alg].P8_N      := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].P8_ID     := 0;        //пока никуда не указывает
  Blok_Alg[U_Alg].I         := 1;        //показываем, что если будет выполняться, то - это будет первый цикл
  Blok_Alg[U_Alg].Flg_Zanat := True;     //ставим флаг, что данная ячейка "занята"
   //меняем указатель на текущую "пустую" ячейку
  U_Z_Alg := Blok_Alg[U_Alg].Next_P;     //меняем указатель на "пустую" ячейку (берем её из текущей ячейки)
//  Blok_Alg[U_Alg].Next_Z    := 0;        //сбрасываем указатель на следующую "пустую" ячейку (так как эта ссылка будет не действительна)
  Blok_Alg[U_Alg].Next_P    := U_P_Alg;  //показываем на предыдущую занятую ячейку
  Blok_Alg[U_Alg].Pred_P    := 0;        //предыдущая в 0 - так как эта ячейка станет первой в очереди
  Blok_Alg[U_P_Alg].Pred_P  := U_Alg;    //зато у предыдущей ячеки меняем указатель - теперь он указывает на эту
  U_P_Alg                   := U_Alg;    //а указатель на первую занятую ячейку ставим на текущую ячейку (она теперь первая)

    //делаем запись и в массив ячеек описывающих ветки CASE (так как одна ветка всегда создается по-умолчанию)
   U_CASE := U_Z_CASE; //берем указатель на первую "свободную" ячейку в массиве "связанных" ячеек веток CASE
//   P_N_Alg      : Integer;   //Номер в массиве Алгоритмов, на который ссылается данная процедура
//   ID_Rod       : Integer;   //ID родительской записи в БД Алгоритмов (в которой описаны эти ветки CASE)
//   Alg_Rod      : Integer;   //номер ячейки с родительским Алгоритмом
  Blok_CASE[U_CASE].ID        := ID_CASE; //ID записи в БД веток CASE
  Blok_CASE[U_CASE].N         := 1;       //по-умолчанию, номер ветки всегда 1 (так как создается только она одна)
  Blok_CASE[U_CASE].P         := 'Null';  //пустая процедура
  Blok_CASE[U_CASE].P_N_Alg   := 0;       //пока никуда не указывает
  Blok_CASE[U_CASE].P_ID      := 0;       //пока никуда не указывает
  Blok_CASE[U_CASE].ID_Rod    := ID_Rod;  //ID родительской записи
  Blok_CASE[U_CASE].Alg_Rod   := U_Alg;   //номер ячейки родительского Алгоритма
  Blok_CASE[U_CASE].Flg_Zanat := True;    //ставим флаг, что данная ячейка занята
   //меняем указатель на текущую "пустую" ячейку
  U_Z_CASE := Blok_CASE[U_CASE].Next_P;    //меняем указатель на "пустую" ячейку (берем её из текущей ячейки)
//  Blok_CASE[U_CASE].Next_Z    := 0;        //сбрасываем указатель на следующую "пустую" ячейку (так как ветка всего одна)
  Blok_CASE[U_CASE].Next_N    := 0;        //следующей ячейке в этом блоке CASE нет (всего одна ветка по умолчанию)
  Blok_CASE[U_CASE].Pred_N    := 0;        //предыдущей ветки тоже нет (так как всег оодна ветка)
  Blok_CASE[U_CASE].Next_P    := U_P_CASE; //показываем на предыдущую занятую ячейку
  Blok_CASE[U_CASE].Pred_P    := 0;        //предыдущей у неё нет, так как теперь она первая в очереди
  Blok_CASE[U_P_CASE].Pred_P  := U_CASE;   //зато в прошлой ячейке меняем указатель на предыдущую - тепреь он указывает на эту
  U_P_CASE                    := U_CASE;   //указатель на первую занятую ячейку ставим на текущую

   //устанавливаем указатель на эту ячейку (веток CASE) в ячейке в массиве Алгоритмов
  Blok_Alg[U_Alg].U_1_CASE    := U_CASE;  //ссылка на первую ветку в массиве блоков CASE

   //меняем состояние счетчиков
  Kol_Alg  := Kol_Alg + 1;   //меняем количество заполненных ячеек в массиве Алгоритмов
  Kol_CASE := Kol_CASE + 1;  //меняем количество заполненных ячеек в массиве веток CASE

  Form1.Edit1.Text := IntToStr(Form1.Tb_Prm_Int.FieldByName('KOL_PRC').AsInteger); //выводим на экран кол-во процедур в БД

 end; //конец процедуры cmd_Sozdat(S : String); //если была введена команда СОЗДАТЬ (процедуру)

 //======================================================
 //процедура НАЗВАТЬ (процедуру) - введено нове имя для нее
procedure cmd_Nazvat(S : String); //если была введена команда НАЗВАТЬ (процедуру) - введено новое имя для нее
 var
//  int_i  : Integer; //переменная для организации циклов
  int_ID : Integer; //для получения ID текущей записи БД
  s1     : String;  //временная строка
//  U_Tek  : Integer; //временный указатель на ячейку
//  Flag   : Boolean; //флаг для поиска нужной ячейки

 begin
   //берем из исходной введенной человеком строки оставшуюся после команды НАЗВАТЬ часть
  s1 := Copy(s,8,100); //берем из введенной строки все символы с 8-го и до конца (100 символов макс)
  s1 := Trim(s1);      //удаляем пробелы в начале и в конце получившейся строки
   Form1.M1.Lines.Add('Введенное имя: ' + s1);    //переносим то, что получилось, в диалоговое окно
   Form1.E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
    //создаем имя для этой процедуры и заносим его в БД имен процедур
  ID_Rod := Form1.Tb_Alg.FieldByName('ID').AsInteger; //берем ID родителя (текущая запись в БД Алгоритмов)
  s_ID   := IntToStr(ID_Rod);  //преобразуем ID_Rod в закавыченный текст

   //смотрим, нет ли уже у данной процедуры своего имени (возможно, такая запись в БД имен уже есть)
  if not Form1.Tb_Im.Locate('ID_ALG',s_ID,[]) then //если такая запись не найдена
   begin
    Form1.Tb_Im.Insert; //добавляем (создаем) новую запись (пустую)
     Form1.Tb_Im.FieldByName('ID_ALG').AsInteger  := ID_Rod;  //запоминаем ID родительской записи в БД Алгоритмов
     Form1.Tb_Im.FieldByName('DLN_IM').AsString   := s1;      //а сюда - введенное человеком имя процедуры
    Form1.Tb_Im.Post; //подтверждаем сделанные изменения
   end  //конец добавления новой записи с присвоением имени процедуры
  else //если такая запись уже существует, то присваиваем этой процедуре новое имя
   begin
    Form1.Tb_Im.Edit;  //Открывает БД имен процедур для редактирования
    Form1.Tb_Im.FieldByName('DLN_IM').AsString   := s1;   //заносим введенное человеком новое имя процедуры
    Form1.Tb_Im.Post;  //подтверждаем сделанные изменения
   end; //конец ввода нового названия для процедуры

   //сохраняем ссылку на эту запись и в БД Алгоритмов
    //берем ID сделанной записи длинного имени в БД Алгоритмов
   int_ID := Form1.Tb_Im.FieldByName('ID').AsInteger; //берем ID этой записи в БД длинных имен
  Form1.Tb_Alg.Edit; //открываем на редактирование БД Алгоритмов
   Form1.Tb_Alg.FieldByName('IM_ID').AsInteger := int_ID; //делаем запись
  Form1.Tb_Alg.Post; //подтверждаем изменения

   //переносим название (имя процедуры, если есть) в строку Заголовок
  s_Im := Form1.Tb_Im.FieldByName('DLN_IM').AsString; //берем имя процедуры (если оно там есть)
  Form1.L_Im.Caption := s_Im; //переносим полученное имя процедуры в окно строки

   //проверяем состояние ячеек в массиве Алгоритмов (активны ли они, и совпадают ли с текущей записью)
   //делаем активной ячейку совпадающую с текущей записью в БД Алгоритмов (если нет, то создаем новую)
  Pozicia();              //процедура поиска и выставления активной ячейки по текущей записи в БД Алгоритмов

   //заносим новое имя в текущую ячейку в массиве Алгоритмов
  Blok_Alg[U_Alg].DLN_IM  := s_Im;       //и присваиваем имя даное человеком, если оно есть

 end; //конец процедуры cmd_Nazvat(S : String); //если была введена команда НАЗВАТЬ (процедуру) - введено новое имя для нее

{TODO: Убрать в команде знак "="} 
 //======================================================
 //процедура cmd_Vetok - если была введена команда ВЕТОК (задать количество ветвей в блоке CASE)
procedure cmd_Vetok(S : String); //если была введена команда ВЕТОК (задать количество ветвей в блоке CASE)
 var
  int_i   : Integer; //вспомогательная переменная

//  s1      : string;  //вспомогательная строка
//  s2      : string;  //вспомогательная строка
//  s3      : string;  //вспомогательная строка
//  s_Fild : string;  //строка для формирования названия поля
//  N_Fild : Integer; //для вычисления номера блока
//  Cmnd   : TComand; //для хранения введенной комманды

  Int_Old : Integer; //старое значение NCASE
  U_Tek   : Integer; //временный текущий указатель на какую-нибудь ячейку

//  Flag    : Boolean; //логическая переменная для учета

 begin
  U_Tek := 0; //инициируем текущее значение

  input_NCASE(s); //вызываем вспомогательную процедуру для анализа введенной строки

   //смотрим, что в итоге получилось (правильно ли было введено число)
 if log_Flag then //если флаг правильности ввода числа выставлен
  begin

    //но сначала нужно проверить, какая стоит активная ячейка Алгоритмов, и есть ли она
     //возможно три варианта:
      // 1) текущая ячейка совпадает с текущей записью в БД Алгоритмов (только что с ней работали);
      // 2) нет ячеек в массиве Алгоритмов (еще не работали, но захотели изменить);
      // 3) текущая ячейка не совпадает с записью в БД Алгоритмов (работали с другой ячейкой) -
      // - нужно искать, и если нет, то - создать новую ячейку

   Pozicia(); //процедура поиска и выставления активной ячейки по текущей записи в БД Алгоритмов

    ID_Rod  := Form1.Tb_Alg.FieldByName('ID').AsInteger;   //ID этой записи в БД Алгоритмов
    Int_Old := Blok_Alg[U_Alg].NC; //берем старое значение количества веток NCASE

    //проверяем какое число введено: меньше старого или больше/равно
      //три варианта:
       // 1) введенное число РАВНО старому значению - делать ничего не нужно
       // 2) введенное число БОЛЬШЕ старого значения - добавляем необходимое число веток
       // 3) введенное число МЕНЬШЕ старого значения - нужно удалить лишние наиболее старшие ветки блока CASE
     //когда новое значение равно старому, то вообще ничего не делаем (делаем, когда либо меньше, либо больше)

   if Int_N > Int_Old then //введенное число БОЛЬШЕ старого значения NCASE
     //введенное число больше старого значения NCASE (добавляем новые пустые ветки)
    begin //добавляем недостающие ветки (активная ячейка уже стоит на нужной записи БД)

       //пролистываем все имеющиеся ветки CASE в массиве ячеек до последней
      U_Tek := Blok_Alg[U_Alg].U_1_CASE; //берем указатель на первую ячейку в массиве веток CASE
     for int_i:= 1 to Int_Old do //пролистываем весь список этих ячеек от первого до старого значения
      begin
       U_Tek := Blok_CASE[U_CASE].Next_N; //берем в текущей ячейке указатель на следующую ячейку
      end;

      //добавляем новые ячейки и записи в БД CASE по числу недостающих
     for int_i:= Int_Old+1 to Int_N do //с того места, где закончили, и до введенного числа
      begin
        //сначала добавляем запись в БД веток CASE
       Form1.Tb_CASE.Insert; //добавляем (создаем) новую запись (пустую)
        Form1.Tb_CASE.FieldByName('ID_ROD').AsInteger  := ID_Rod;  //запоминаем ID родительской записи в БД Алгоритмов
        Form1.Tb_CASE.FieldByName('NCASE').AsInteger   := int_i;   //номер этой ветки CASE
        Form1.Tb_CASE.FieldByName('P').AsString        := 'Null';  //пустая процедура
        Form1.Tb_CASE.FieldByName('P_ID').AsInteger    := 0;       //указываем на несуществующую процедуру
       Form1.Tb_CASE.Post; //подтверждаем сделанные изменения

         // а теперь добавляем ячейку в массив ячеек CASE
        ID_CASE := Form1.Tb_CASE.FieldByName('ID').AsInteger;  //берем ID только что созданной записи в БД веток CASE
        U_CASE  := U_Z_CASE; //берем указатель на первую "свободную" ячейку в массиве "связанных" ячеек веток CASE
       Blok_CASE[U_CASE].ID        := ID_CASE;  //ID записи в БД веток CASE
       Blok_CASE[U_CASE].N         := int_i;    //номер этой ветки CASE
       Blok_CASE[U_CASE].P         := 'Null';   //пустая процедура
       Blok_CASE[U_CASE].P_N_Alg   := 0;        //пока никуда не указывает
       Blok_CASE[U_CASE].P_ID      := 0;        //пока никуда не указывает
       Blok_CASE[U_CASE].Flg_Zanat := True;     //ставим флаг, что данная ячейка занята

        //меняем указатель на текущую "пустую" ячейку
       U_Z_CASE := Blok_CASE[U_CASE].Next_Z;    //меняем указатель на "пустую" ячейку (берем её из текущей ячейки)
       Blok_CASE[U_CASE].Next_Z    := 0;        //сбрасываем указатель на следующую "пустую" ячейку (так как ветка всего одна)

        //меняем цепочку "занятых" ячеек"
       Blok_CASE[U_CASE].NEXT_N    := U_P_CASE; //показываем на предыдущую занятую ячейку
       U_P_CASE                    := U_CASE;   //указатель на первую занятую ячейку ставим на текущую
      end; //конец цикла добавления недостающих веток CASE

       //меняем количество веток CASE в записи основного алгоритма
      Form1.Tb_Alg.Edit; //открываем для редактирования текущую запись в БД Алгоритмов
       Form1.Tb_Alg.FieldByName('NC').AsInteger   := int_N;   //новое количество ветвей CASE
      Form1.Tb_Alg.Post; //подтверждаем сделанные изменения

       //и в активной ячейке Алгоритмов тоже
      Blok_Alg[U_Alg].NC     := int_N;        //новое количество ветвей CASE

          //производим отбор строк, которые относятся к текущему алгоритму (ID_ROD = ID текущей записи в БД Alg)
      Form1.Tb_CASE.Filtered := True;   //включаем фильтрацию
      ID_CASE := Form1.Tb_CASE.FieldByName('ID').AsInteger; //берем ID записи из БД CASE для этой ветки

    end //конец условия, что введенное число больше старого

   else if Int_N < Int_Old then //введенное число МЕНЬШЕ старого значения NCASE
    begin //нужно удалить "лишние" ветки

       //пролистываем все имеющиеся ветки CASE в массиве ячеек до последней
      U_Tek := Blok_Alg[U_Alg].U_1_CASE; //берем указатель на первую ячейку в массиве веток CASE
     for int_i:= 1 to Int_N do //пролистываем весь список этих ячеек от первого до введенного нового значения
      begin
       U_Tek := Blok_CASE[U_CASE].Next_N; //берем в текущей ячейке указатель на следующую ячейку
      end;
       //U_Tek показывает на последнюю ячеку в блоке ячеек CASE равную новому введеному
       //удаляем все следующие до конца (обнуляя ячейки и записи в БД CASE)
     for int_i:= Int_N+1 to Int_Old do //с того места, где закончили, и до старого значения
      begin
        //сначала удаляем запись в БД веток CASE
//       Form1.Tb_CASE.Insert; //добавляем (создаем) новую запись (пустую)
           //
//       Form1.Tb_CASE.Post; //подтверждаем сделанные изменения

         // а теперь добавляем ячейку в массив ячеек CASE
        ID_CASE := Form1.Tb_CASE.FieldByName('ID').AsInteger;  //берем ID только что созданной записи в БД веток CASE
        U_CASE  := U_Z_CASE; //берем указатель на первую "свободную" ячейку в массиве "связанных" ячеек веток CASE
       Blok_CASE[U_CASE].ID        := ID_CASE;  //ID записи в БД веток CASE
       Blok_CASE[U_CASE].N         := int_i;    //номер этой ветки CASE
       Blok_CASE[U_CASE].P         := 'Null';   //пустая процедура
       Blok_CASE[U_CASE].P_N_Alg   := 0;        //пока никуда не указывает
       Blok_CASE[U_CASE].P_ID      := 0;        //пока никуда не указывает
       Blok_CASE[U_CASE].Flg_Zanat := True;     //ставим флаг, что данная ячейка занята

        //меняем указатель на текущую "пустую" ячейку
       U_Z_CASE := Blok_CASE[U_CASE].Next_Z;    //меняем указатель на "пустую" ячейку (берем её из текущей ячейки)
       Blok_CASE[U_CASE].Next_Z    := 0;        //сбрасываем указатель на следующую "пустую" ячейку (так как ветка всего одна)

        //меняем цепочку "занятых" ячеек"
       Blok_CASE[U_CASE].NEXT_N    := U_Z_CASE; //показываем на предыдущую занятую ячейку
       U_Z_CASE                    := U_CASE;   //указатель на первую занятую ячейку ставим на текущую
      end; //конец цикла добавления недостающих веток CASE

    end //конец условия, что ввденное значение меньше старого NCASE  (когда новое значение равно старому - деать ничего не нужно)

  end //конец условия, что флаг правильности ввода числа выставлен (число введено правильно)
 else //флаг стоит в значении ЛОЖЬ (команда введена неверно)
  begin
   Form1.M1.Lines.Add('Команда введена неправильно');    //пишем, что данная команда введена неправильно
   Form1.E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
  end;

 end; //конец процедуры cmd_NCASE(); //если была введена команда NCASE (задать количество ветвей в блоке CASE)

 //======================================================
 //процедура input_NCASE - если была введена команда NCASE (ввод строковой части команды)
procedure input_NCASE(S : String); //если была введена команда NCASE (ввод строковой части команды)
 var
//  int_i   : Integer; //вспомогательная переменная
  s1      : string;  //вспомогательная строка
  s2      : string;  //вспомогательная строка
  s3      : string;  //вспомогательная строка
//  s_Fild : string;  //строка для формирования названия поля
//  N_Fild : Integer; //для вычисления номера блока
//  Cmnd   : TComand; //для хранения введенной комманды
//  Int_N   : Integer; //введенное число для кол-ва веток CASE
//  Int_Old : Integer; //старое значение NCASE
//  Flag    : Boolean; //логическая переменная для учета
//  U_Tek   : Integer; //временный текущий указатель на какую-нибудь ячейку

 begin
    //готовим переменные
  Int_N     := 0;     //обнуляем переменную для хранения введенного количества ветвей блока CASE
  log_Flag  := False; //сбрасываем флаг (что введено правильное число)

   //берем из исходной введенной человеком строки оставшуюся после команды NCASE часть
  s1 := Copy(s,6,100); //берем из введенной строки все символы с 6-го и до конца (100 символов макс)
  s1 := Trim(s1);      //удаляем пробелы в начале и в конце получившейся строки (первым символом должен стать "=")
  Form1.M1.Lines.Add('Введенное содержимое: ' + s1);    //переносим то, что получилось, в диалоговое окно
  Form1.E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)

    //проверяем, если там символ "="
   s := Copy(s1,1,1); //берем из введенной строки все символы с 1-го и до 1-го (то есть, один символ)
  if s = '=' then // если знак "равно" есть, то проверяем дальше
   begin
     //берем из исходной введенной человеком строки оставшуюся после команды NCASE и знака "=" часть
    s := Copy(s1,2,100); //берем из введенной строки все символы со 2-го и до конца (100 символов макс)
    s := Trim(s);        //удаляем пробелы в начале и в конце получившейся строки
     //проверяем, что там
    if NOT (s = '') then //если оставшаяся часть - не пустая строка
     begin
      s1 := Copy(s,1,1); //берем из введенной строки все символы с 1-го и до 1-го (то есть, один 1-й символ)
      s2 := Copy(s,2,1); //берем из введенной строки все символы с 2-го и до 2-го (то есть, один 2-й символ)
      s3 := Copy(s,3,1); //берем из введенной строки все символы с 3-го и до 3-го (то есть, один 3-й символ)
      s := Copy(s,4,100); //берем из введенной строки все символы со 4-го и до конца (100 символов макс)
       //первый символ есть всегда (так как не пустое содержимое) - проверяем, что там
      if (s1='1') OR (s1='2') OR (s1='3') OR (s1='4') OR (s1='5') OR (s1='6') OR (s1='7') OR (s1='8') OR (s1='9') OR (s1='0') then
       begin //если первый символ - это цифра от 1 до 0, то значит, все в порядке
        Int_N := StrToInt(s1); //переводим первый символ в цифру
         //смотрим второй символ
        if NOT (s2 = '') then //если второй символ не пустой - есть продолжение
         begin
          if (s2='1') OR (s2='2') OR (s2='3') OR (s2='4') OR (s2='5') OR (s2='6') OR (s2='7') OR (s2='8') OR (s2='9') OR (s2='0') then
           begin //если второй символ - это цифра от 1 до 0, то значит, все в порядке
            Int_N := Int_N*10+ StrToInt(s2); //переводим второй символ в цифру и добавляем его к числу
             //смотрим третий символ
            if NOT (s3 = '') then //если третий символ не пустой - есть продолжение
             begin
              if (s3='1') OR (s3='2') OR (s3='3') OR (s3='4') OR (s3='5') OR (s3='6') OR (s3='7') OR (s3='8') OR (s3='9') OR (s3='0') then
               begin //если третий символ - это цифра от 1 до 0, то значит, все в порядке
                Int_N := Int_N*10+ StrToInt(s3); //переводим третий символ в цифру и добавляем его к числу
                  //проверяем, что осталось в строке (вдруг есть продолжение, что плохо)
                if s = '' then //если продолжения нет, то значит все в порядке - было введено 3 символа, и это цифры
                 begin
                   //проверяем на максимально возможное количество ветвей в блоке CASE
                  if  (Int_N > 0) AND (Int_N < 256) then  //если введенное число не равно 0 (больше 0) и меньше 256
                   begin
                     //указываем, что все верно
                    log_Flag := True; //ставим флаг, что все в порядке
                   end
                  else //введенное число не вписывается в этот диапазон
                   begin
                    Form1.M1.Lines.Add('Количество ветвей в блоке CASE должно быть меньше 256 и не должно быть равно 0');    //пишем, что данная команда введена неправильно
                    Form1.E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
                   end;
                 end; //конец условия, что после 3-го символа больше ничего нет
               end //конец проверки третьего символа
              else
               begin
                Form1.M1.Lines.Add('количество ветвей в блоке CASE следует указывать цифраи');    //пишем, что данная команда введена неправильно
                Form1.E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
               end;
             end //конец условия, что третий символ не пустой
            else //если третий символ "пустой" - введено только два символа
             begin
               //проверяем на максимально возможное количество ветвей в блоке CASE
              if  (Int_N > 0) AND (Int_N < 256) then  //если введенное число не равно 0 (больше 0) и меньше 256
               begin
                 //указываем, что все верно
                log_Flag := True; //ставим флаг, что все в порядке
               end
              else //введенное число не вписывается в этот диапазон
               begin
                Form1.M1.Lines.Add('Количество ветвей в блоке CASE должно быть меньше 256 и не должно быть равно 0');    //пишем, что данная команда введена неправильно
                Form1.E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
               end;
             end; //конец условия, что введено только два символа
           end //конец проверки второго символа
          else
           begin
            Form1.M1.Lines.Add('количество ветвей в блоке CASE следует указывать цифраи');    //пишем, что данная команда введена неправильно
            Form1.E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
           end;
         end //конец условия, что второй символ не пустой
        else //если второй символ "пустой" - введен только один символа
         begin
           //проверяем на максимально возможное количество ветвей в блоке CASE
          if  (Int_N > 0) AND (Int_N < 256) then  //если введенное число не равно 0 (больше 0) и меньше 256
           begin
             //указываем, что все верно
            log_Flag := True; //ставим флаг, что все в порядке
           end
          else  //введенное число не вписывается в этот диапазон
           begin
            Form1.M1.Lines.Add('Количество ветвей в блоке CASE должно быть меньше 256 и не должно быть равно 0');    //пишем, что данная команда введена неправильно
            Form1.E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
           end;
         end; //конец условия, что введен только один символ
       end //конец проверки первого символа
      else
       begin
        Form1.M1.Lines.Add('количество ветвей в блоке CASE следует указывать цифраи');    //пишем, что данная команда введена неправильно
        Form1.E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
       end; //
     end //конец условия, что после знака "=" есть содержимое
    else //если после знака "=" ничего больше нет (команда введена неверно)
     begin
      Form1.M1.Lines.Add('Не введено количество ветвей для блока CASE');    //пишем, что данная команда введена неправильно
      Form1.E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
     end;
   end //конец условия, что знак "=" в введенной строчке есть
  else //если знака равно после команды NCASE нет (команда введена неверно)
   begin
    Form1.M1.Lines.Add('Нет знака "="');    //пишем, что данная команда введена неправильно
    Form1.E1.SetFocus;         //возвращаем фокус ввода в строку редактирования (в окно ввода команды)
   end;

 end; //конец процедуры input_NCASE(); //если была введена команда NCASE (ввод строковой части команды)

 //======================================================
 //процедура заполнения ячеек массивов по текущей записи БД (указатель стоит, ячейки еще не заполнены)
procedure Zap_Tek_Alg();         //процедура заполнения ячеек массивов по текущей записи БД
 var
  int_i : Integer; //переменная для организации циклов
  int_N : Integer; //для хранения количества ветвей CASE
  s_ID  : String;  //для преобразования ID в строку
  s_Num : String;  //для преобразования номера ветки CASE в строку
  s1    : String;  //строковая переменная
  U_Pred_CASE : Integer; //для отслеживания цепочки веток одного блока CASE
 begin
  //
//  TAlg = record
//    //основные данные (см. схему Стандартоной Универсальной Процедуры)
//   ID           : Integer;    //порядковый номер записи в БД (её ID)
//   IM           : String[15]; //имя этой процедуры (в БД строка 15 символов) - генерирует программа
//   DLN_IM       : String[50]; //длинное имя процедуры, если его даст человек
//   P1           : String[20]; //Процедура 1 (см. схему), выражение, либо вызов другой процедуры (вызов - просто номер записи в массиве Алгоритмов)
//   P1_N         : Integer;    //Номер в массиве Алгоритмов, на который ссылается данная процедура
//   P1_ID        : Integer;    //ID записи в БД Алгоритмов, на которую ссылается данная процедура
//   P2           : String[20]; //Процедура 2 (см. схему), либо выражение
//   P2_N         : Integer;    //Номер в массиве Алгоритмов, на который ссылается данная процедура
//   P2_ID        : Integer;    //ID записи в БД Алгоритмов, на которую ссылается данная процедура
//   U1           : String[30]; //Условие 1 (см. схему), логическое выражение
//   P3           : String[20]; //Процедура 3 (см. схему), либо выражение
//   P3_N         : Integer;    //Номер в массиве Алгоритмов, на который ссылается данная процедура
//   P3_ID        : Integer;    //ID записи в БД Алгоритмов, на которую ссылается данная процедура
//   NC           : Integer;    //количество ветвей в выборе CASE (сами ветки в другой БД)
//   P4           : String[20]; //Процедура 4 (см. схему), либо выражение
//   P4_N         : Integer;    //Номер в массиве Алгоритмов, на который ссылается данная процедура
//   P4_ID        : Integer;    //ID записи в БД Алгоритмов, на которую ссылается данная процедура
//   U2           : String[30]; //Условие 2 (см. схему), логическое выражение
//   P5           : String[20]; //Процедура 5 (см. схему), либо выражение
//   P5_N         : Integer;    //Номер в массиве Алгоритмов, на который ссылается данная процедура
//   P5_ID        : Integer;    //ID записи в БД Алгоритмов, на которую ссылается данная процедура
//   P6           : String[20]; //Процедура 6 (см. схему), либо выражение
//   P6_N         : Integer;    //Номер в массиве Алгоритмов, на который ссылается данная процедура
//   P6_ID        : Integer;    //ID записи в БД Алгоритмов, на которую ссылается данная процедура
//   P7           : String[20]; //Процедура 7 (см. схему), либо выражение
//   P7_N         : Integer;    //Номер в массиве Алгоритмов, на который ссылается данная процедура
//   P7_ID        : Integer;    //ID записи в БД Алгоритмов, на которую ссылается данная процедура
//   P8           : String[20]; //Процедура 8 (см. схему), либо выражение
//   P8_N         : Integer;    //Номер в массиве Алгоритмов, на который ссылается данная процедура
//   P8_ID        : Integer;    //ID записи в БД Алгоритмов, на которую ссылается данная процедура
//   I            : Integer;    //текущее значение выполняемого цикла (для подсчета и организации цикла типа For)
//   U_1_CASE     : Integer;    //ссылка на самую первую запись в блоке (массиве) ветвей CASE
//   Flg_Zanat    : Boolean;    //флаг занятости/свободы этой ячейки
//   Next_P       : Integer;    //указатель на следующую "занятую" ячейку для их корректного удаления
//   Pred_P       : Integer;    //указатель на предыдущую "занятую" ячейку для их корректного удаления
//   Next_Z       : Integer;    //указатель на следующую "связанную" "пустую" ячейку в цепочке (для удобного заполнения)

//  TCASEPrcdr = record
//    //основные данные (см. схему Стандартоной Универсальной Процедуры для блока CASE)
//   ID           : Integer;   //порядковый номер записи в БД CASEBD (её ID)
//   N            : Integer;   //номер этой ветки в блоке CASE
//   P            : String;    //выражение, либо имя вызываемой процедуры
//   P_N          : Integer;   //Номер в массиве Алгоритмов, на который ссылается данная процедура
//   P_ID         : Integer;   //ID записи в БД Алгоритмов, на которую ссылается данная процедура
//   Flg_Zanat    : Boolean;   //флаг занятости/свободы этой ячейки
//   Next_P       : Integer;   //указатель на следующую "занятую" ячейку для их обхода при проверке
//   Pred_P       : Integer;   //указатель на предыдущую "занятую" ячейку (для корректного удаления)
//   Next_N       : Integer;   //указатель на следующую ячейку - ветку в этом же блоке CASE - для их обхода при проверке
//   Pred_N       : Integer;   //указатель на предыдущую ячейку - ветку в этом же блоке CASE - (для корректного удаления)
//   Next_Z       : Integer;   //указатель на следующую "связанную" "пустую" ячейку в цепочке

//   //массив "связанных" ячеек для хранения Алгоритмов ("связанные" они потому, что указывают на следующую "пустую")
//  Blok_Alg  : array[1..5000] of TAlg;  //5000 ячеек для "связанных" записей Универсальных Алгоритмов
//  U_Z_Alg   : Integer;   //указатель на первую "свободную" ячейку в таблице "связанных" ячеек для записи Алгоритмов
//  U_P_Alg   : Integer;   //указатель на первую "занятую" ячейку в массиве Алгоритмов
//  U_Alg     : Integer;   //указатель на текущую ячйку в массиве алгоритмов
//  Kol_Alg   : Integer;   //количество заполненных ячеек в массиве Алгоритмов
//   //для организации хранения записей значений ветвей в блоках CASE
//  Blok_CASE : array[1..20000] of TCASEPrcdr; //20000 ячеек для "связанных" записей отдельных ветвей в блоках CASE
//  U_Z_CASE  : Integer;   //указатель на первую "свободную" ячейку в таблице "связанных" записей ветвей блоков CASE
//  U_P_CASE  : Integer;   //указатель на первую "занятую" ячейку в массиве веток CASE
//  U_CASE    : Integer;   //указатель на текущую ячейку в таблице записей ветвей блоков CASE
//  Kol_CASE  : Integer;   //количество заполненных ячеек в массиве веток CASE

      //заполняем значениями структуру Универсального Алгоритма в массиве
       ID_Rod := Form1.Tb_Alg.FieldByName('ID').AsInteger; //берем ID родителя (текущая запись в БД Алгоритмов)

       //записываем в первую текущую "пустую" ячейку - на неё показывает указатель
      U_Alg := U_Z_Alg; //берем указатель на первую (текущую) "свободную" ячейку в массиве Алгоритмов
     Blok_Alg[U_Alg].ID        := ID_Rod;   //ID записи в БД Алгоритмов
     Blok_Alg[U_Alg].IM        := Form1.Tb_Alg.FieldByName('IM').AsString;     //имя, типа PRCN
     Blok_Alg[U_Alg].DLN_IM    := '';       //временно - "пустое имя"
     Blok_Alg[U_Alg].P1        := Form1.Tb_Alg.FieldByName('P1').AsString;     //процедура P1
     Blok_Alg[U_Alg].P1_N      := 0; //пока никуда не указывает, так как не запускали - а должен - на нужную ячейку
     Blok_Alg[U_Alg].P1_ID     := Form1.Tb_Alg.FieldByName('P1_ID').AsInteger; //указатель на запись этой процедуры в БД
     Blok_Alg[U_Alg].P2        := Form1.Tb_Alg.FieldByName('P2').AsString;     //процедура P2
     Blok_Alg[U_Alg].P2_N      := 0;        //пока никуда не указывает
     Blok_Alg[U_Alg].P2_ID     := Form1.Tb_Alg.FieldByName('P2_ID').AsInteger; //указатель на запись этой процедуры в БД
     Blok_Alg[U_Alg].U1        := Form1.Tb_Alg.FieldByName('U1').AsString;     //условие U1
     Blok_Alg[U_Alg].P3        := Form1.Tb_Alg.FieldByName('P3').AsString;     //процедура P3
     Blok_Alg[U_Alg].P3_N      := 0;        //пока никуда не указывает
     Blok_Alg[U_Alg].P3_ID     := Form1.Tb_Alg.FieldByName('P3_ID').AsInteger; //указатель на запись этой процедуры в БД
     Blok_Alg[U_Alg].NC        := Form1.Tb_Alg.FieldByName('NC').AsInteger;    //количество ветвей в блоке CASE
     Blok_Alg[U_Alg].NAME      := Form1.Tb_Alg.FieldByName('NAME').AsString;   //имя пользовательской переменной
     Blok_Alg[U_Alg].TIP       := Form1.Tb_Alg.FieldByName('TIP').AsInteger;   //тип пользоваетльской переменной
     Blok_Alg[U_Alg].SPISOK    := Form1.Tb_Alg.FieldByName('SPISOK').AsString; //список значений пользовательской переменной
     Blok_Alg[U_Alg].P4        := Form1.Tb_Alg.FieldByName('P4').AsString;     //процедура P4
     Blok_Alg[U_Alg].P4_N      := 0;        //пока никуда не указывает
     Blok_Alg[U_Alg].P4_ID     := Form1.Tb_Alg.FieldByName('P4_ID').AsInteger; //указатель на запись этой процедуры в БД
     Blok_Alg[U_Alg].U2        := Form1.Tb_Alg.FieldByName('U2').AsString;     //условие U2
     Blok_Alg[U_Alg].P5        := Form1.Tb_Alg.FieldByName('P5').AsString;     //процедура P5
     Blok_Alg[U_Alg].P5_N      := 0;        //пока никуда не указывает
     Blok_Alg[U_Alg].P5_ID     := Form1.Tb_Alg.FieldByName('P5_ID').AsInteger; //указаетль на запись этой процедуры в БД
     Blok_Alg[U_Alg].P6        := Form1.Tb_Alg.FieldByName('P6').AsString;     //процедура P6
     Blok_Alg[U_Alg].P6_N      := 0;        //пока никуда не указывает
     Blok_Alg[U_Alg].P6_ID     := Form1.Tb_Alg.FieldByName('P6_ID').AsInteger; //указаетль на запись этой процедуры в БД
     Blok_Alg[U_Alg].P7        := Form1.Tb_Alg.FieldByName('P7').AsString;     //процедура P7
     Blok_Alg[U_Alg].P7_N      := 0;        //пока никуда не указывает
     Blok_Alg[U_Alg].P7_ID     := Form1.Tb_Alg.FieldByName('P7_ID').AsInteger; //указаетль на запись этой процедуры в БД
     Blok_Alg[U_Alg].P8        := Form1.Tb_Alg.FieldByName('P8').AsString;     //процедура P8
     Blok_Alg[U_Alg].P8_N      := 0;        //пока никуда не указывает
     Blok_Alg[U_Alg].P8_ID     := Form1.Tb_Alg.FieldByName('P8_ID').AsInteger; //указаетль на запись этой процедуры в БД
     Blok_Alg[U_Alg].I         := 1;        //показываем, что если будет выполняться, то - это будет первый цикл
     Blok_Alg[U_Alg].Flg_Zanat := True;     //ставим флаг, что данная ячейка "занята"
      //меняем указатель на текущую "пустую" ячейку
     U_Z_Alg := Blok_Alg[U_Alg].Next_Z;     //меняем указатель на "пустую" ячейку (берем её из текущей ячейки)
     Blok_Alg[U_Alg].Next_Z    := 0;        //сбрасываем указатель на следующую "пустую" ячейку (так как эта ссылка будет не действительна)
     Blok_Alg[U_Alg].Next_P    := U_P_Alg;  //показываем на предыдущую занятую ячейку
     Blok_Alg[U_Alg].Pred_P    := 0;        //предыдущей нет, так как наша теперь первая занятая
     Blok_Alg[U_P_Alg].Pred_P  := U_Alg;    //зато у старой ячейки меняем указаетль на предыдущую - теперь это наша ячейка
     U_P_Alg                   := U_Alg;    //а указатель на первую занятую ячейку ставим на текущую ячейку

      //делаем запись и в массив ячеек описывающих ветки CASE (поскольку создаем ячейку Алгоритмов, то создаем и ячейки CASE для нее)
     int_N := Blok_Alg[U_Alg].NC; //берем количество созданных веток в блоке CASE у этого Алгоритма
     s_ID  := IntToStr(ID_ROD); //ID родителя - БД Алгортмов - в строку
     U_Pred_CASE := 0 ; //ставим уазатель на предущую ячейку ветки CASE в 0
      //организуем цикл по количеству созданных веток в блоке CASE
     For int_i := 1 to int_N do //сколько ветвей у блока CASE
      begin
        s_Num := IntToStr(int_i);  //текущий номер ветки CASE - в строку
         //ищем в БД веток CASE эту запись
       //if Form1.Tb_CASE.Locate('ID_ROD;NCASE',VarArrayOf([s_ID, s_Num]),[]) then //если такая запись найдена
        begin
         ID_CASE := Form1.Tb_CASE.FieldByName('ID').AsInteger; //берем ID записи этой ветки блока CASE
          U_CASE  := U_Z_CASE; //берем указатель на первую "свободную" ячейку в массиве "связанных" ячеек веток CASE
          //заполняем значения
         Blok_CASE[U_CASE].ID        := ID_CASE; //ID записи в БД веток CASE
         Blok_CASE[U_CASE].N         := int_i;   //номер этой ветки
         Blok_CASE[U_CASE].P         := Form1.Tb_CASE.FieldByName('P').AsString;     //процедура этой ветки CASE
         Blok_CASE[U_CASE].P_N_Alg   := 0;  //пока никуда не указывает, так как не вызывали
         Blok_CASE[U_CASE].P_ID      := Form1.Tb_CASE.FieldByName('P_ID').AsInteger; //ссылка на запись в БД Алгоритмов
         Blok_CASE[U_CASE].Flg_Zanat := True;    //ставим флаг, что данная ячейка занята

          //меняем указатель на текущую "пустую" ячейку (цепочка "пустых" ячеек)
         U_Z_CASE := Blok_CASE[U_CASE].Next_Z;    //меняем указатель на "пустую" ячейку (берем её из текущей ячейки)
         Blok_CASE[U_CASE].Next_Z    := 0;        //сбрасываем указатель на следующую "пустую" ячейку (так как ветка всего одна)
          //цепочка веток в одном блоке CASE
         Blok_CASE[U_CASE].Next_N    := 0;        //пока следующей ячейки нет (она последняя)
         Blok_CASE[U_CASE].Pred_N      := U_Pred_CASE; //показываем на предыдущую ячейку  вэтом же блоке CASE
         Blok_CASE[U_Pred_CASE].Next_N := U_CASE;      //в предыдущей ячейке этого же блока CASE меняем ссылку на следуюущую (на эту)
         U_Pred_CASE                   := U_CASE;      //  меняем значение указателя на предыдущую ячейку
          //цепочка заполненных ячеек ы массиве веток CASE
         Blok_CASE[U_CASE].Next_P    := U_P_CASE; //показываем на предыдущую занятую ячейку
         Blok_CASE[U_P_CASE].Pred_P  := U_CASE;   //а в старой - предыдущая указывает на новую
         Blok_CASE[U_CASE].Pred_P    := 0;        //а у этой ячейки предыдущей нет
         U_P_CASE                    := U_CASE;   //указатель на первую занятую ячейку ставим на текущую

          //и только один раз, для самой первой ветки блока CASE
         if int_i = 1 then //если номер ветки CASE равен 1
          begin
            //устанавливаем указатель на эту ячейку (веток CASE) в ячейке в массиве Алгоритмов
           Blok_Alg[U_Alg].U_1_CASE    := U_CASE;  //ссылка на первую ветку в массиве блоков CASE
          end;

          //меняем состояние счетчиков
         Kol_CASE := Kol_CASE + 1;  //меняем количество заполненных ячеек в массиве веток CASE

        end; //конец условия, что такую запись в БД CASE нашли
       end; //конец цикла For по всем веткам блока CASE у этого Алгоритма

        //работаем с длинным именем процедуры, если оно есть
      s_ID := IntToStr(Form1.Tb_Alg.FieldByName('IM_ID').AsInteger); //ID записи в БД длинных имен процедур
     if  (NOT (s_ID='0')) AND (Form1.Tb_Im.Locate('ID',s_ID,[])) then //ставим указатель на эту запись
      begin
       s1 := Form1.Tb_Im.FieldByName('DLN_IM').AsString; //берем длинное имя из БД
       Blok_Alg[U_Alg].DLN_IM    := s1;       //переносим это имя в ячейку Алгоритмов
      end;

      //меняем состояние счетчиков
     Kol_Alg  := Kol_Alg + 1;   //меняем количество заполненных ячеек в массиве Алгоритмов

 end; //конец процедуры Zap_Tek_Alg();  //процедура заполнения ячеек массивов по текущей записи БД

 //======================================================
 //процедура поиска и выставления активной ячейки по текущей записи в БД Алгоритмов
procedure Pozicia();              //процедура поиска и выставления активной ячейки по текущей записи в БД Алгоритмов
 var
  int_i : Integer;  //переменная для организации циклов
  U_Tek : Integer;  //указатель на текущую ячейку
  Flag  : Boolean;  //флаг для обработки алгоритма

 begin
   //проверяем состояние ячеек в массиве Алгоритмов (активны ли они, и совпадают ли с текущей записью)
    //три варианта:
     // 1) ячейка есть, и совпадает с текущей записью БД Алгоритмов - делать ничего не надо
     // 2) массив Алгоритмов пуст (пользователь только что начал работать с программой и захотел поменть имя процедуры)
     // 3) массив ячеек не пуст (уже работали с программой), но текущая ячейка не совпадает с текущей записью в БД
     // и тогда - нужно искать по всему массиву ячеек, и либо находим, либо - записываем в новую ячейку

   U_Tek := U_P_Alg;  //берем первую заполненную ячейку
   Flag  := False;    //сбрасываем флаг

  if U_Alg = 0 then //если указатель на текущую ячейку алгоритмов равен 0 (с программой еще не работали)
   begin
    Zap_Tek_Alg(); //создаем новую ячейку и заполняем значения в новой ячейке по текущей записи БД
   end //конец условия, что массив Алгоритмов еще не создан

  else if NOT (Blok_Alg[U_Tek].ID = ID_Rod) then  //а тут - массив Алгоритмов не пуст, но активная ячейка не совпадает с текущей записью БД Алгоритмов - надо искать
   begin //у нас есть переменная Kol_Alg - количество заполненных ячеек в массиве Алгоритмов - организуем цикл поиска
    for int_i := 1 to Kol_Alg do //по количеству заполненных ячеек
     begin
      if Blok_Alg[U_Tek].ID = ID_Rod then //если текущая ячейка указывает на текущую запись БД Алгоритмов
       begin
        U_Alg := U_Tek;  //делаем эту ячейку активной
        Flag  := True;   //устанавливаем флаг, что нашли
         Break;  //вываливаемся из цикла For
       end
      else //если текущая ячейка не та
       begin
         //смещаемся по цепочке занятых ячеек
        U_Tek := Blok_Alg[U_Tek].Next_P; //берем следующую заполненную
       end;
     end; //конец поиска по всем созданным ячейкам

      //смотрим, что получилось (нашли или нет)
    if NOT Flag then //если НЕ нашли
     begin
      Zap_Tek_Alg(); //создаем новую ячейку и заполняем значения в новой ячейке по текущей записи БД
     end;

   end; //конец условия, что массив Алгоритмов не пуст, но активная ячейка не совпадает с текущей записью БД Алгоритмов

 end; //конец процедуры Pozicia();   //процедура поиска и выставления активной ячейки по текущей записи в БД Алгоритмов

 //======================================================

procedure cmd_Blok(S: String);
var
  R: TExplodeResult;
  P: Byte;
  PN, Code: string;
begin
   R := Explode(S);
   // Этап I - узнаем номер блока
   if Length(R) > 1 then
   begin
     P := StrToIntDef(R[1], 0);
     if P in [1..8] then
       begin
       PN := 'P' + IntToStr(P);
       Dialog('Номер блока:', PN);
       end
     else begin Dialog('Ошибка: блок под номером ' + PN + ' не найден!'); Exit; end;
   end else begin Dialog('Ошибка: не указан номер блока!'); Exit; end;
   // Этап II - записываем команды в этот блок
   if Length(R) > 2 then
   begin
     Code := Trim(Implode(R, 2));
     Form1.Tb_Alg.SaveToField(PN, Code);
   end else begin Dialog('Ошибка: не указан исполняемый код для блока', PN); Exit; end;
end;

procedure cmd_Vypolnit(S: String);
var
  R: TExplodeResult;
  AlgName: string;
begin
  {TODO: Нужна проверка на правильность ввода имени алгоритма}
  R := Explode(S);
  // Получаем название алгоритма
  if Length(R) > 1 then
  begin
    AlgName := Trim(Implode(R, 1));
    Form1.DoCmdRun(AlgName);
  end else Dialog('Ошибка: нужно ввести название существующего алгоритма!');
end;

procedure cmd_Uslovie(S: String);
var
  R: TExplodeResult;
  U: Byte;
  UN, Code: string;
begin
   R := Explode(S);
   // Этап I - узнаем номер условия (U1 или U2)
   if Length(R) > 1 then
   begin
     U := StrToIntDef(R[1], 0);
     if U in [1..2] then
       begin
       UN := 'U' + IntToStr(U);
       Dialog('Условие:', UN);
       end
     else begin Dialog('Ошибка: условие под номером ' + UN + ' не найдено!'); Exit; end;
   end else begin Dialog('Ошибка: не указан номер условия!'); Exit; end;
   // Этап II - записываем команды в этот блок условия
   if Length(R) > 2 then
   begin
     Code := Trim(Implode(R, 2));
     Form1.Tb_Alg.SaveToField(UN, Code);
   end else begin Dialog('Ошибка: не указан исполняемый код для условия', UN); Exit; end;
end;

end.
